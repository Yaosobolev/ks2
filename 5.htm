<html>
<!-- Creation date: 03.10.2005 -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title></title>
<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="Unregistered User">
<meta name="generator" content="CuteHTML Pro">
<link rel="StyleSheet" type="text/css" href="style.css">
</head>
<body bgcolor="#FFFFFF">
<!--*************************************************************************************-->
<p align="center">
		<a name="5"><font class="big">5 Сети TCP/IP</font></a>
</p>
<p align="center">
		<a name="5.1"><font class="big">5.1 Принцип работы архитектуры "клиент-сервер"</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Революция, вызванная появлением персональных компьютеров, сделала возможным иметь вычислительные и информационные ресурсы на рабочем столе пользователя и управлять ими по собственному разумению с помощью цветного оконного графического интерфейса. Увеличение производительности ПК позволило перенести части системы (интерфейс с пользователем, приклад¬ную логику) для выполнения на персональном компьютере, непосредственно на рабочем месте, а функции обработки данных оставить на центральном компью¬тере. Система стала распределенной - одна часть функций выполняется на цен¬тральном компьютере, другая - на персональном, который связан с централь¬ным посредством коммуникационной сети. Таким образом, появилась клиент-серверная модель взаимодействия компьютеров и программ в сети и на этой основе стали развиваться средства разработки приложений для реализации ин¬формационных систем.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>Под сервером</em> в широком смысле понимается любая система, процесс, компьютер, владеющие каким-либо вычислительным ресурсом (памятью, временем, производительностью процессора и т. д.).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>Клиентом</em> называется также любая система, процесс, компьютер, пользователь, запрашивающие у сервера какой-либо ресурс, пользующиеся каким-либо ресурсом или обслуживаемые сервером иным способом.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В последнее время долю обработки, приходящуюся на клиента, стали называть "толщиной" клиента.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Развитие архитектуры "клиент-сервер" происходит по спирали и в настоящее время намечается тенденция централизации вычислений, то есть замены "толстых" клиентов - рабочих станций на основе высокопроизводительных ПЭВМ, оснащенных мощным программным обеспечением для поддержки прикладных про¬грамм, мультимедийных средств, навигационного и графического интерфейса - "тонкими" клиентами. Характерный пример "тонкого" клиента - архитектура Sun Ray Hot Desk, предложенная компанией Sun Microsystems.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Архитектура Sun Ray Hot Desk предполагает использование настольных систем типа графических терминалов Sun Ray 1, имеющих минимум программных и аппаратных средств, но обладающих широкими возможностями работы с приложениями в соответствии с основной идеей "тонких" клиентов - вынести на сервер все, вплоть до виртуальных драйверов устройств, включая драйвер монитора (рисунок 5.1).</p>
<p align="center"><img src="img/chapter5/5.1.jpg"/></p>
<p align="center">Рисунок 5.1 - Ранжирование клиентов по "толщине"</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Компоненты "клиент" и "сервер" не обязательно должны работать на разных машинах, хотя обычно это так и есть - клиент-приложение находится на рабочей станции пользователя, а сервер - на специальной выделенной машине. Наиболее распространены следующие виды серверов: файл-серверы, серверы баз данных, серверы печати, серверы электронной почты, Web-сервер и другие.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Однако двухуровневая архитектура "клиент-сервер" имеет та¬кие существенные недостатки, как сложность администрирования и низкая ин-формационная безопасность.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Архитектура клиент-сервер лежит в основе одной из  популярного стека TCP/IP.</p>
</font>
<p align="center">
		<a name="5.2"><font class="big">5.2 Основы межсетевого взаимодействия на основе протоколов TCP/IP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP/IP - собирательное название для стека сетевых протоколов разных уровней, используемых в Интернет. Термин "TCP/IP" обозначает технологию межсетевого взаимодействия на основе семейства протоколов TCP и IP (рисунок 4.2).</p>
<p align="center"><img src="img/chapter5/5.2.jpg"/></p>
<p align="center">Рисунок 5.2 - Связь протоков в узле TCP/IP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В это семейство вхо¬дят протоколы UDP, ARP, ICMP, TELNET, FTP и многие другие.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Рассматривая многоуровневую архитектуру TCP/IP, можно выделить в ней, подобно архитектуре OSI, уровни, функции которых зависят от конкретной технической реализации сети, и уровни, функции которых ориентированны на работу с приложениями. Другими словами, сетезависимые и сетенезависимые уровни стека TCP/IP (рисунок 5.3).</p>
<p align="center"><img src="img/chapter5/5.3.jpg"/></p>
<p align="center">5.3 - Сетезависимые и сетенезависимые уровни стека TCP/IP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протоколы прикладного уровня стека TCP/IP работают на компьютерах, выполняющих приложения пользователей. Даже полная смена сетевого оборудования в общем случае не должна влиять на работу приложений, если они получают доступ к сетевым возможностям через протоколы прикладного уровня.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протоколы транспортного уровня уже более зависят от сети, так как они реализуют интерфейс к уровням, непосредственно организующим передачу данных по сети. Однако, подобно протоколам прикладного уровня, программные модули, реализующие протоколы транспортного уровня, устанавливаются только на конечных узлах. Протоколы двух нижних уровней являются сетезависимыми, а следовательно, программные модули протоколов межсетевого уровня и уровня сетевых интерфейсов устанавливаются как на конечных узлах составной сети, так и на маршрутизаторах.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый коммуникационный протокол оперирует с некоторой единицей передаваемых данных. Названия этих единиц иногда закрепляются стандартом, а чаще просто определяются традицией. В стеке TCP/IP за многие годы его существования образовалась устоявшаяся терминология в этой области (рисунок 5.4).</p>
<p align="center"><img src="img/chapter5/5.4.jpg"/></p>
<p align="center">Рисунок 5.4 - Название единиц данных, используемых в TCP/IP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Потоком называют данные, поступающие от приложений на вход протоколов транспортного уровня TCP и UDP. Протокол TCP нарезает из потока данных сегменты. Единицу данных протокола UDP часто называют дейтаграммой (или дейтаграммой). Дейтаграмма - это общее название для единиц данных, которыми оперируют протоколы без установления соединений. К таким протоколам относится и протокол межсетевого взаимодействия IP. Дейтаграмму протокола IP называют также пакетом.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Кратко работа протоколов TCP/IP может быть описана следующим образом. Протокол TCP разбивает информацию на порции и нумерует все порции, чтобы при получении можно было правильно собрать информацию. После добавления TCP–заголовка протокол TCP передает дейтаграм¬му протоколу IP. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол IP добавляет к каждой дейтаграмме заголовок адреса. Заго¬ловок включает в себя адреса отправителя и получателя каждой дейта-граммы. После этого протокол IP передает дейтаграмму компьютеру-отправителю.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пока пакет путешествует по сети Интернет, он проходит через не-сколько IP-маршрутизаторов. Каждый маршрутизатор читает ад¬рес назначения пакета и выбирает адрес порта следующего маршрутизатора, ко¬торому нужно послать пакет, чтобы тот достиг узла назначения. Вслед-ствие того, что поток информации в сети никогда не бывает постоян¬ным, то разные пакеты могут идти через различные маршрутизаторы. Кроме того, некоторые маршрутизаторы могут не работать по какой-либо причи-не. Если маршрутизатор IP обнаруживает, что адрес занят или не работает, то он выбирает альтернативный адрес, по которому и посылает пакет.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Из всего этого следует, что пакеты могут прибыть по назначению со-всем не в том порядке, в котором они были отправлены из исходного узла. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По¬сле того как получающий компьютер принимает пакет, он первым делом проверяет верхний и нижний заголовок пакета, чтобы удостовериться в корректности содержащейся в нем дейтаграммы. Для этого рассчитывается контрольная сумма, которая сравнивается с исход-ной. Контрольная сумма - это число, помещаемое в дейтаграмму и вычисляемое по специальному алгоритму для всех символов дейтаграммы. Если контрольные суммы не совпадают, то посылается запрос на повторную отправку пакета. После получения и проверки всех дейта-грамм, TCP восстанавливает их порядок, удаляет заголовки, собирает в единое целое и передает информацию получающему протоколу прикладного уровня.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для протокола TCP не имеет значения, какими путями информация путешествует по Интернет. Этим занимается протокол IP. К каждой полученной порции информации протокол IP добавляет служебную информацию, из которой можно узнать адреса отправителя и получателя информации. Если следовать аналогии с почтой, то данные помещаются в конверт, на котором пишется адрес получателя.</p>
<p align="center"><img src="img/chapter5/5.5.jpg"/></p>
<p align="center">Рисунок 5.5 - Схема функционирования протокола TCP/IP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Архитектура протоколов TCP/IP предназначена для объединенной сети, состоящей из соединенных друг с другом шлюзами отдельных разнородных пакетных подсетей, к которым подключаются разнородные машины. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Использование во всех узлах и маршрутизаторах межсетевого протокола IP решает проблему доставки паке¬тов. Таким образом, обеспечивается дейтаграммный сервис на межсетевом уровне Internet. Этот уровень обеспечивает возможность стандартизации про¬токолов верхних уровней и является основой архитектуры ТСР/IР.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Имеется прямая связь между функциональной сложностью протокола и сложностью заголовка пакетов, которые этот протокол использует. Это объясняется тем, что основные служебные данные, на основании которых протокол выполняет то или иное действие, переносятся между двумя модулями, реализующими этот протокол на разных машинах, именно в полях заголовков пакетов. Поэтому очень полезно изучить назначение каждого поля заголовка IP-пакета, и это изучение дает не только формальные знания о структуре пакета, но и объясняет все основные режимы работы протокола по обработке и передаче IP-дейтаграмм. </p>
</font>
<p align="center">
		<a name="5.3"><font class="big">5.3 Сетевой уровень. Протокол IP</font></a>
</p>
<p align="center">
		<a name="5.3.1"><font class="big">5.3.1 Формат заголовка IP-дейтаграммы</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP-дейтаграмма состоит из заголовка и данных. Заголовок дейтаграммы состоит из 32-разрядных слов. За заголовком непосредственно следуют данные, передаваемые в дейтаграмме. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Имеется прямая связь между количеством полей заголовка  пакета и функциональной сложностью протокола, который работает с этим заголовком. Чем проще заголовок – тем проще соответствующие протокол. Большая часть действий протокола связана с обработкой той служебной информации, которая переносится в полях заголовка пакета. Изучая назначение каждого поля заголовка IP-пакета, можно получить не только формальные знания о структуре пакета, но и знакомиться с основными функциями протокола IP (рисунок 5.6).</p>
<p align="center"><img src="img/chapter5/5.6.jpg"/></p>
<p align="center">Рисунок 5.6 - Формат заголовка IP-дейтаграммы</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значения полей заголовка следующие.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ver – поле номера версии занимает 4 бита и идентифицирует версию протокола IP. Сейчас используется версия 4 (IPv4), хотя чаще всего встречается и новая версия (IPv6).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IHL – значение длины заголовка занимает 4 бита и измеряется в 32-битных словах. Обычно заголовок имеет длину в 20 байт (пять 32-битных слов), но при добавлении некоторой служебной информации это значение может быть увеличено за счет дополнительных байтов в поле параметров. Наибольшая длина заголовка составляет 60 байт.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TOS – тип сервиса занимает 8 бит и имеет и другое, более современное название – байт дифференцированного обслуживания, или DS-байт.  Этим двум названиям соответствуют два варианта интерпретации этого поля. В обоих случаях данное поле служит одной цели – хранению признаков, которые отражают требования к качеству обслуживания пакета. В прежнем варианте три бита содержат значение приоритета пакета: от самого низкого 0 до самого высокого -7. Маршрутизаторы и компьютеры могут принимать во внимание приоритет пакета и обрабатывать более важные пакеты в первую очередь.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующие три бита TOS определяют критерий выбора маршрута. Если бит D (Delay –задержка) установлен в 1, то маршрут должен выбираться для минимизации задержки доставки данного пакета, установленный бит Т (Throughput – пропускная способность) – для максимизации пропускной способности, бит R (Reliability - надежность) – для максимизации надежности доставки, а C (Cost - стоимость) – минимизация маршрута по стоимости. Оставшиеся два бита имеют нулевое значение.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total Length – поле общей длины занимает 2 байта и характеризует общую длину пакета с учетом заголовка и поля данных. Максимальная длина пакета ограничена разрядностью поля, определяющего эту величину и составляет 65535 байт, однако в большинстве компьютеров и сетей столь большие пакеты не используются. При передаче по сетям раз личного типа длина пакета выбирается с учетом максимальной длины пакета протокола нижнего уровня, несущего IP-пакеты. Если это кадры Ethernet, то выбираются пакеты с максимальной длиной1500 байт, умещающиеся в поле данных кадра Ethernet. В стандартах TCP/IP предусматривается, что все хосты должны быть готовы принимать пакеты длиной вплоть до 576 байт (не зависимо от того, приходят ли он целиком или фрагментами).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ID – идентификатор пакета занимает 2 байта и используется для распознавания пакетов, образовавшихся путем деления на части (фрагментации) исходного пакета. Все части (фрагменты) одного пакета должны иметь одинаковое значение этого поля.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flags – флаги занимают 3 бита и содержат признаки, связанные с фрагментацией. Установленный в 1 бит DF (Do not Fragment – не фрагментировать) запрещает маршрутизатору фрагментировать данный пакет, а установленный в 1 бит (MF) (More Fragment – больше фрагментов) говорит о том, что данный пакет является промежуточным (не последним) фрагментом. Оставшийся бит зарезервирован.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fragment Offset – поле смещения фрагмента занимает 13 бит и задает смещение в байтах поля данных этого фрагмента относительно начала поля начала данных исходного (нефрагментированного) пакета. Используются при сборке/разборке фрагментов пакетов. Смещение должно быть кратно 8 байт.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TTL - поле время жизни дейтаграммы занимает 1 байт  и используется для задания предельного срока, в течении которого пакет может перемещаться по сети. Время жизни пакета измеряется в секундах и задается источником. По истечении каждой секунды пребывания на каждом из маршрутизаторов, через которые проходит пакет во время своего "путешествия" по сети, из его текущего времени жизни вычитается единица; единица вычитается и в том случае, если время пребывания было меньше секунды. Поскольку современные маршрутизаторы редко обрабатывают пакет дольше, чем одну секунду, то время жизни можно интерпретировать как максимальное число транзитных узлов, которые разрешено пройти пакету. Если значение поля времени жизни становится нулевым до того, как пакет достигает получателя, пакет уничтожается. Таким образом, время жизни является своего рода часовым механизмом самоуничтожения пакета.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Protocol – поле протокола верхнего уровня занимает один байт и содержит идентификатор, указывающий, какому протоколу верхнего уровня принадлежит информация, размещенная в поле данных пакета. Значения идентификаторов для разных протоколов для разных протоколов используются различные (например, 6 обозначает, что в пакете находится сообщение протокола TCP, 17 – протокола UDP, 1 – протокола ICMP).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Header Checksum - контрольная сумма заголовка занимает 16 бит и рассчитывается только по заголовку. Поскольку некоторые поля заголовка меняют свое значение в процессе передачи пакета по сети (например, поле времени жизни), контрольная сумма проверяется и повторно рассчитывается на каждом маршрутизаторе и конечном узле как дополнение к сумме всех 16-битных слов заголовка. При вычислении контрольной суммы значение самого поля контрольной суммы устанавливается в нуль. Если контрольная сумма неверна, то пакет отбрасывается, как только обнаруживается ошибка.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source Address - IP-адрес источника имеет длину 32 бита.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destination Address  - IP-адрес назначения имеет длину 32 бита.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options – поле параметров является необязательным и используется обычно только при отладке сети. Это поле состоит из нескольких подполей одного из восьми предопределенных типов. В этих полях можно указывать точный маршрут, регистрировать проходимые пакетов маршрутизаторы, помещать данные системы безопасности или временные отметки.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padding - выравнивание заголовка по границе 32-битного слова. Так как число подполей в поле параметров может быть произвольным, то в конце заголовка должно быть добавлено несколько нулевых байтов для выравнивания заголовка пакета по 32-битной границе.</p>
</font>
<p align="center">
		<a name="5.3.2"><font class="big">5.3.2 Типы адресов стека TCP/IP</font></a>
</p>
<font class="norm">
<ul>Компьютер в сети может иметь адреса трех уровней:
<li>локальный (аппаратный) адрес,</li>
<li>сетевой адрес (IP-адрес),</li>
<li>символьный (доменное) имя.</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При этом, не существует никакой функциональной зависимости между локальными адресами и сетевыми адресами, также между сетевыми адресами и символьными именами. Для того чтобы уставить соответствие между MAC-адреса IP-адресу используются так называемые ARP-таблицы. В свою очередь, чтобы установить соответствие между IP-адресом и доменным именем, можно воспользоваться службой DNS.</p>
</font>
<p align="center">
		<a name="5.3.2.1"><font class="big">5.3.2.1 Локальные адреса</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В большинстве технологий LAN (Ethernet, FDDI, Token Ring) для однозначной адресации интерфейсов используются MAC-адреса. Существует немало технологий (Х.25, ATM, Frame Relay), в которых применяются другие схемы адресации. Роль, которую играют эти адреса в TCP/IP, не зависит от того, какая именно технология используется в подсети, поэтому они имеют общее название – локальные (аппаратные) адреса.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Слово "локальный" в контексте TCP/IP означает "действующий не во всей составной сети, а лишь в пределах подсети". Именно в таком смысле понимается здесь термины: "локальная технология" (технология, на основе которой построена подсеть) и "локальный адрес" (адрес, который используется некоторой локальной технологией для адресации узлов в пределах подсети). </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При этом, в качестве подсети ("локальной сети") может выступать сеть, построенная на основе локальной технологии, например Ethernet, FDDI, так и на основе глобальной технологии, например X.25, Frame Relay. Следовательно, говоря о подсети, используется термин "локальная" не как характеристика технологии, на которой построена подсеть, а как указание на роль, которую играет эта подсеть в архитектуре составной сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сложности могут возникнуть и при  интерпретации определения "аппаратный". В данном случае термин "аппаратный" подчеркивает концептуальное представление разработчиков стека TCP/IP о подсети, как о некотором вспомогательном аппаратном средстве, единственной функцией которого является перемещение IP-пакета через подсеть до ближайшего шлюза (маршрутизатора). И не важно, что реально нижележащая локальная технология может быть достаточно сложной, все ее сложности технологией TCP/IP игнорируются.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Например, в составную сеть TCP/IP входит сеть IPX/SPX. Последняя сама может быть разделена на подсети, и так же как IP-сеть, она идентифицирует свои узлы аппаратными средствами IPX-адресами. Но технология TCP/IP игнорирует многоуровневое строение сети IPX/SPX и рассматривает в качестве локальных адресов узлов подсети IPX/SPX адреса сетевого уровня данной технологии (IPX-адреса). Аналогично, если в составную сеть включена сеть X.25, то локальными адресами узлов этой сети для протокола IP будут соответственно адреса X.25.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Локальный адрес узла, определяемый технологией, с помощью которой построена отдельная сеть, в которую входит данный узел. Для узлов, входящих в локальные сети - это МАС-адрес сетевого адаптера или порта маршрутизатора, например, 11-А0-17-3D-BC-01. Эти адреса назначаются производителями оборудования и являются уникальными адресами, так как управляются централизовано. Для всех существующих технологий локальных сетей МАС-адрес имеет формат 6 байтов: старшие 3 байта - идентификатор фирмы производителя, а младшие 3 байта назначаются уникальным образом самим производителем. Для узлов, входящих в глобальные сети, такие как Х.25 или Frame Relay, локальный адрес назначается администратором глобальной сети.</p>
</font>
<p align="center">
		<a name="5.3.2.2"><font class="big">5.3.2.2 Сетевые IP-адреса</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы технология TCP/IP могла решать свою задачу объединения сетей, ей необходима собственная глобальная система адресации, не зависящая от способов адресации узлов в отдельных сетях. Эта система адресации должна позволять универсальным и однозначным способом идентифицировать любой интерфейс составной сети. Очевидным решением является уникальная нумерация всех сетей составной сети, а затем нумерация всех узлов в пределах каждой из этих сетей. Пара, состоящая из номера сети и номера узла, отвечает поставленным условиям и может являться сетевым адресом.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В качестве номера узла может выступать либо уникальный адрес этого узла, либо некоторое число, никак не связанное с локальной технологией и однозначно идентифицирующее узел в пределах данной подсети. В первом случае сетевой адрес становится зависимым от локальных технологий, что ограничивает его применение. Например, сетевые адреса IPX/SPX рассчитаны на работу в составных сетях, объединяющих сети, в которых используется только MAC-адреса или адреса аналогичного формата. Второй подход более универсален, он характерен для стека TCP/IP. В технологии TCP/IP сетевой адрес называют IP-адресом.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если рассматривать IP-сеть, то можно отметить, что маршрутизатор входит в несколько сетей, следовательно, каждый его интерфейс имеет собственный IP-адрес. Конченый узел также может входить в несколько IP-сетей. В этом случае компьютер должен иметь несколько IP¬-адресов – по числу сетевых связей. Таким образом, IP-адрес идентифицирует не отельный компьютер или маршрутизатор, а одно сетевое соединение.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый раз, когда пакет направляется адресату через составную сеть, в его заголовке указывается IP-адрес узла назначения. По номеру сети назначения каждый очередной маршрутизатор находит IP-адрес следующего маршрутизатора. Перед тем, как отправить пакет в следующую сеть, маршрутизатор должен определить на основании найденного IP-адреса следующего маршрутизатора его локальный адрес. Для этой цели протокол IP, как показано на рисунке 5.8, обращается к протоколу разрешения адресов ARP.</p>
<p align="center"><img src="img/chapter5/5.7.jpg"/></p>
<p align="center">Рисунок 5.7 – Преобразование адресов</p>
</font>
<p align="center">
		<a name="5.3.2.3"><font class="big">5.3.2.3 Доменные имена</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для идентификации компьютеров аппаратное и программное обеспечение в сетях TCP/IP полагается на IP адреса. Например, команда ftp://192.45.66.17 устанавливать сеанс связи с нужным сервером, а команда http://203.23.106.33. откроет начальную страницу на корпоративном Web-сервере. Однако пользователи обычно предпочитают работать с более удобными символьными именами компьютеров.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Символьные идентификаторы сетевых интерфейсов в пределах составной сети строятся по иерархическому принципу. Составляющие полного символьного (доменного) имени  в IP-сетях разделяются точкой и перечисляются в следующем порядке: сначала простое имя хоста, затем имя группы хостов (например, имя организации), потом имя более крупной группы (домена) и так до имени домена самого высокого уровня (например, домена, объединяющего организации по географическому принципу: RU – Россия, UK – Великобритания, US - США). Примером доменного имени может служить base.sales.zil.ru.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Между доменными именем и IP-адресом нет никакой функциональной зависимости, поэтому единственный способ установления соответствия – это таблица. В сетях TCP/IP используется специальная система доменных имен (Domain Name System, DNS) которая устанавливает это соответствие на основании создаваемых администратором сети таблиц соответствия. Поэтому доменные имена называют также DNS-именами.
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В общем случае сетевой интерфейс может иметь несколько локальных адресов, сетевых адресов и доменных имен.</p>
</font>
<p align="center">
		<a name="5.3.3"><font class="big">5.3.3 IP-адресация</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Любой IP-адрес состоит из четырех чисел в интервале от 1 до 254, разделенных точками. В схемах IP-адресации также могут ис¬пользоваться числа 0 и 255, но они зарезервированы для специальных целей. Число 255 используется для направления дейтаграммы всем ком¬пьютерам сети IP. Число 0 используется для более точного указания ад¬реса.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP-адрес имеет длину 4 байта и обычно записывается в виде четырех чисел, представляющих значения каждого байта в десятичной форме и разделенных точками, например, 128.10.2.30 - традиционная десятичная форма представления адреса, а 10000000 00001010 00000010 00011110 - двоичная форма представления этого же адреса.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Адрес состоит из двух логических частей - номера сети и номера узла в сети. Какая часть адреса относится к номеру сети, а какая - к номеру узла, определяется значениями первых бит адреса.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.8  показана структура IP-адреса разных классов.</p>
<p align="center"><img src="img/chapter5/5.8.jpg"/></p>
<p align="center">Рисунок 5.8 - Структура IP-адреса</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.1 иллюстрирует структуру IP-адресов разных классов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.1 – Классы IP-адресов</p>
<table border="1" align="center"> ololo
	<tr>
    	<td>Класс</td>
       	<td>Первые биты</td>
        <td>Наименьший номер сети</td>
        <td>Наибольший номер сети</td>
        <td>Максимальное число узлов в сети</td>
    </tr>
    <tr>
    	<td>A</td>
        <td>0</td>
        <td>1.0.0.0 (0 – не используется)</td>
        <td>126.0.0.0 (127 - зарезервирован)</td>
        <td>2<sup>24</sup>, поле 3 байта</td>
    </tr>
    <tr>
   		<td>B</td>
      	<td>10</td>
      	<td>128.0.0.0</td>
      	<td>191.255.0.0</td>
      	<td>2<sup>16</sup>, поле 2 байта</td>
  	</tr>
    <tr>
   		<td>C</td>
      	<td>110</td>
      	<td>192.0.0.0</td>
      	<td>223.255.255.0</td>
      	<td>2<sup>8</sup>, поле 1 байта</td>
  	</tr>
    <tr>
   	  	<td>D</td>
      	<td>1110</td>
      	<td>224.0.0.0</td>
      	<td>239.255.255.255</td>
      	<td>Multicast (групповые адреса)</td>
  	</tr>
    <tr>
   	  	<td>E</td>
      	<td>11110</td>
      	<td>240.0.0.0</td>
      	<td>247.255.255.255</td>
      	<td>Зарезервировано</td>
  	</tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- к классу А относится адрес, в котором старший бит имеет значение 0. В адресах класса А под идентификатор сети отводится 1 байт, а остальные 3 байта интерпретируется как номер узла в сети. Сети, все IP-адреса которых имеют значение первого байта в диапазоне от 1 (00000001) до 126 (01111110), называются сетями класса А. Значение 0 (00000000) первого байта не используется, а значение 127 (01111111) зарезервировано для специальных целей. Сетей класса А немного, зато количество узлов в них может достигать 2<sup>24</sup>, то есть 16777216 узлов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- к классу В относятся все адреса, старшие два байта которых имеют значение 10. В адресе класса В под номер сети и под номер узла отводится 2 байта. Сети, значения первых двух байтов адресов которых находятся в диапазоне от 128.0 (10000000.00000000) до 191.255 (10111111.11111111), называются сетями класса В. Ясно, сетей класса В больше, чем сетей класса А, а размеры их меньше. Максимальное количество узлов в сетях класса В составляет 2<sup>16</sup> (65 536).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- к классу С относятся все адреса, старшие три бита которых имеют значение 110. В адресах класса С под номер сети отводится 3 байта, а под номер узла – 1 байт. Сети, старшие три байта которых находятся в диапазоне от 192.0.0.0 (11000000.00000000.00000000) до 223.255.255 (11011111.11111111.11111111), называются сетями класса С. Сети класса С наиболее распространены, и максимальное число узлов в них равно 2<sup>8</sup> (256).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- если адрес начинается с последовательности 1110, то он является адресом класса D и означает особый групповой адрес (multicast address). В то время как адреса класса А, В и С служат для идентификации отдельных сетевых интерфейсов, то есть являются индивидуальными адресами (unicast address), групповой адрес идентифицирует группу сетевых интерфейсов, которые в общем случае могут принадлежать к разным сетям. Интерфейс, входящий в группу, получает наряду с обычным индивидуальным IP адресом еще один групповой адрес. Если при отправке пакета в качестве адреса сети назначения указан адрес класса D, то такой пакет должен быть доставлен всем узлам, которые входят в группу.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если адрес начинается с последовательности 11110, то это значит, что данный адрес относится к классу E. Адреса этого класса зарезервированы для будущих применений.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы получить из IP адреса номер сети и номер узла, требуется не только разделить адрес на две соответствующие части, но и дополнить каждую из них нулями до полных 4 байт. Например, в адресе класса B - 129.64.134.5 первые два байта идентифицируют сеть, а последние два – узел. Таким образом, номером сети является адрес 129.64.0.0, а номером узла – адрес 0.0.134.5.</p>
</font>
<p align="center">
		<a name="5.3.3.1"><font class="big">5.3.3.1 Особые IP-адреса</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В TCP/IP существуют ограничения при назначении IP-адресов, а именно номера сетей и номера узлов не могут состоять из одних двоичных нулей или единиц. Отсюда следует, что максимальное количество узлов, приведенное в таблице 4.1 для сетей каждого класса, должно быть уменьшено на 2. Например, в адресах класса С под номер узла отводится 8 бит, которые позволяют задать 256 номеров: от 0 до 255. Однако в действительности максимальное число узлов в сети класса С не может превышать 254, так как адреса 0 и 255 запрещены для адресации сетевых интерфейсов. Из этих же соображений следует, что конечный узел не может иметь адрес типа 98.255.255.255, поскольку номер узла в этом адресе класса А состоит из одних двоичных единиц.</p>
<ul>Итак, некоторые IP-адреса интерпретируются особым образом:
<li>Если IP-адрес состоит только из двоичных нулей, то он называется неопределенным адресом и обозначает адрес того узла, который сгенерировал этот пакет. Адрес такого вида, в особых случаях, помещается в заголовок IP-пакета в поле адреса отправителя.</li>
<li>Если в поле номера сети стоят только нули, то по умолчанию считается, что узел назначения принадлежит той же самой сети, что и узел, который отправил пакет. Такой адрес также может быть использован только в качестве адреса отправителя.</li>
<li>Если все двоичные разряды IP-адреса равны 1, то пакет с таким адресом назначения должен рассылаться всем узлам, находящимся в той же сети, что и источник этого пакета. Такой адрес называется ограниченным широковещательным (limited broadcast). Ограниченность в данном случае означает, что пакет не выйдет за границы данной сети не при каких условиях.</li>
<li>Если в поле адреса назначения в разрядах, соответствующих номеру узла стоят только единицы, то пакет, имеющий такой адрес, рассылается всем узлам сети, номер которой указан в адресе назначения. Например, пакет с адресом 192.190.21.255 будет направлен все узлам сети 192.190.21.0. Такой тип адреса называется широковещательным (broadcast).</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что в протоколе IP нет понятия широковещания в том смысле, в котором оно используется в протоколах канального уровня локальных сетей, когда данные должны быть доставлены абсолютно всем узлам сети. Как ограниченный, так и обычный варианты широковещательной рассылки имеют пределы распространения по составной сети: они ограничены либо сетью, которой принадлежит источник пакета, либо сетью, номер которой указан в адресе назначения. Поэтому деление сети с помощью маршрутизаторов на части локализует широковещательный шторм пределами одной из подсетей просто потому, что нет способа адресовать пакет одновременно всем узлам сетей составной сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Особый смысл имеет IP-адрес, первый октет которого равен 127. Этот адрес является внутренним адресом стека протоколов компьютера (или маршрутизатора). Они используется для тестирования программ, а также для организации работы клиентской и серверной частей приложения, установленных на одном компьютере. Обе программные части данного приложения спроектированы в расчете на то, что они будут обмениваться сообщениями по сети. Для этого они должны использовать IP-адрес 127.0.0.0. В IP-сети запрещается присваивать сетевым интерфейсам IP-адреса, начинающиеся со значения 127. Когда программа посылает данные по IP-адресу 127.х.х.х., то данные не передаются в сеть, а возвращаются модулям верхнего уровня того же компьютера как только что принятые. Маршрут перемещения данных образует "петлю", поэтому этот адрес называется адресом обратной связи (localhost).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Уже упоминавшиеся групповые адреса- multicast, относящиеся к классу D, предназначены для распространения в сети Интернет или большой корпоративной сети аудио- или видеопрограмм, адресованных сразу большой аудитории слушателей или зрителей. Если групповой адрес помещен в поле адреса назначения IP-пакета, то данный пакет должен быть доставлен сразу нескольким узлам, которые образую группу с номером, указанным в поле адреса. Один и тот же узел может входить в несколько групп. В общем случае члены группы могут распределяться по различным сетям, находящимся друг от друга на произвольно большом расстоянии. Групповой адрес не делится на номера сети и узла и обрабатывается маршрутизатором особым образом. Основное назначение групповых адресов -  распространение информации по схеме "один ко многим".</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Основное назначение multicast-адресов - распространение информации по схеме "один-ко-многим". Хост, который хочет передавать одну и ту же информацию многим абонентам, с помощью специального протокола IGMP (Internet Group Management Protocol) сообщает о создании в сети новой мультивещательной группы с определенным адресом. Машрутизаторы, поддерживающие мультивещательность, распространяют информацию о создании новой группы в сетях, подключенных к портам этого маршрутизатора. Хосты, которые хотят присоединиться к вновь создаваемой мультивещательной группе, сообщают об этом своим локальным маршрутизаторам и те передают эту информацию хосту, инициатору создания новой группы.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы маршрутизаторы могли автоматически распространять пакеты с адресом multicast по составной сети, необходимо использовать в конечных маршрутизаторах модифицированные протоколы обмена маршрутной информацией, такие как, например, MOSPF (Multicast OSPF, аналог OSPF).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;От того, найдут групповые адреса широкое применение, зависит, сможет ли Интернет создать серьезную конкуренцию радио и телевидению.</p>
</font>
<p align="center">
		<a name="5.3.3.2"><font class="big">5.3.3.2 Использование масок в IP-адресации</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Использование масок позволяет отказаться от понятий классов и адресов и сделать более гибкой систему адресации.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Маска – это число, применяемое в паре с IP-адресом, причем двоичная запись маски содержит непрерывную последовательность единиц в тех разрядах, которые должны интерпретироваться в IP-адресе как номер сети. Граница между последовательностями единиц и нулей в маске соответствует границе между номером сети и номером узла в IP-адресе.</p>
<ul>Для стандартных классов сетей маски имеют следующие значения:
<li>класс А – 11111111.00000000.00000000.00000000 (255.0.0.0)</li>
<li>класс В – 11111111.11111111.00000000.00000000 (255.255.0.0)</li>
<li>класс С – 11111111.11111111.11111111.00000000 (255.255.255.0).</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пусть, например, для IP-адреса 129.64.134.5 указана маска 255.255.128.0, то есть в двоичном виде IP-адрес 129.64.134.5 – это: 10000001.01000000.10000110.00000101, а маска 255.255.128.0 в двоичном виде выглядит так: 11111111.11111111.10000000.00000000.
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если игнорировать маску и интерпретировать адрес 129.64.134.5 на основе классов, то номером сети является 129.64.0.0, а номером узла 0.0.134.5 (поскольку адрес относится к классу B).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если же использовать маску, то 17 последовательных двоичных единиц в маске 255.255.128.0, "наложенных" на IP-адрес 129.64.134.5, делят его на две части, номер сети:10000001.01000000.1 и номер узла: 00000110.00000101
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В десятичной форме записи номера сети и узла, дополненные нулями до 32 бит, выглядят соответственно как 129.64.128.0 и 0.0.6.5. Наложение маски можно интерпретировать как выполнение логической операции И (). Так, в предыдущем примере номер сети из адреса 129.64.134.5 является результатом выполнения логической операции AND с маской 255.255.255.128.0:</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10000001.01000000.10000110.00000101<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11111111.11111111.10000000.00000000
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что для записи масок используются и другие форматы. Например, удобно интерпретировать значение маски, записанной в шестнадцатеричном коде: FF:FF:00:00 – маска для адресов класса . Еще чаще встречается обозначение 185.23.44.206/16 – данная запись говорит о том, что маска для этого адреса содержит 16 единиц или что в указанном IP-адресе под номер сети отведено 16 двоичных разрядов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Механизм масок широко распространен а маршрутизации IP, причем маски могут использоваться для самых разных целей.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;С их помощью администратор может разбивать одну, выделенную ему поставщиком услуг сеть определенного класса на несколько других, не требуя от него дополнительных номеров сетей – эта операция называется разделением на подсети (subnetting). На основе этого же механизма поставщики услуг могут объединять адресные пространства нескольких сетей путем введения так называемых "префиксов" с целью уменьшения объема таблиц маршрутизации и повышения за счет этого производительности маршрутизаторов – такая операция называется объединением подсетей (supernetting).</p>
</font>
<p align="center">
		<a name="5.3.4"><font class="big">5.3.4 Порядок назначения IP-адресов</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По определению схема IP-адресации должна обеспечивать уникальность нумерации сетей, а также уникальность нумерации узлов в пределах каждой из сетей. Следовательно, процедуры назначения номеров как сетям, так и узлам сетей должны быть централизованными.</p>
</font>
<p align="center">
		<a name="5.3.4.1"><font class="big">5.3.4.1 Назначение IP-адресов автономной сети</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда дело касается сети, являющейся частью Интернета, уникальность нумерации может быть обеспечена только усилиями специально созданных для этого центральных органов. В небольшой же автономной IP-сети условие уникальности номеров сетей и узлов может быть выполнено силами сетевого администратора.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В этом случае в распоряжении администратора имеется все адресное пространство, так как совпадение IP-адресов в не связанных между собой сетях не вызовет никаких отрицательных последствий. Администратор может выбирать адреса произвольным образом, соблюдая лишь синтаксические правила, учитывая ограничения на особые IP-адреса. Таким образом, номер узла в технологии TCP/IP назначается независимо о его локального адреса.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Однако при таком подходе исключена возможность в будущем подсоединить данную сеть к Интернету. Действительно, произвольно выбранные адреса данной сети могут совпасть с централизовано назначенными адресами Интернета. Для того, чтобы избежать коллизий, связанных с такого рода совпадениями, в стандартах Интернета определено несколько диапазонов так называемых частных ("серых") адресов, рекомендуемых для автономного использования:
<ul>
<li>в классе А – сеть 10.0.0.0;</li>
<li>в классе В – диапазон из 16 номеров сетей (172.16.0.0-172.31.0.0);</li>
<li>в классе С – диапазон из 255 сетей (192.168.0.0-192.168.255.0).</li>
</ul></p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Эти адреса, исключенные из множества централизованно распределяемых, составляют огромное адресное пространство, достаточное для нумерации узлов автономных сетей практически любых размеров. Частные адреса, как и при произвольном выборе адресов, в разных автономных сетях могут совпадать. В тоже время использование частных адресов для адресации автономных сетей делает возможным корректное подключение к Интернету. Применяемые при этом специальные технологии подключения исключают коллизии адресов.</p>
</font>
<p align="center">
		<a name="5.3.4.2"><font class="big">5.3.4.2 Централизованное распределение адресов</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В больших сетях, подобных Интернету, уникальность сетевых адресов гарантируется централизованной, иерархически организованной системой распределения. Номер сети может быть назначен только по рекомендации специального подразделения Интернета. Главным органом регистрации глобальных адресов в сети Интернет с 1998 года является неправительственная некоммерческая организация ICANN (Internet Corporation for Assiggnet Names and Numbers).Эта организация координирует работу региональных отделов, деятельность которых охватывает большие географические площади. Региональные отделы выделяют блоки адресов сетей крупным поставщикам услуг, а те в свою очередь, распределяют их между своими клиентами, среди которых могут быть и более мелкие поставщики.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Проблемой централизованного распределения адресов является их дефицит. Уже сравнительно давно очень трудно получить адреса класса В и практически невозможно стать обладателем адреса класса А. При этом, дефицит обусловлен не только ростом сетей, но и тем, что имеющееся адресное пространство используется нерационально. Очень часто владельцы сетей класса С расходуют лишь небольшую часть из имеющихся у них 254 адресов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Например, две сети необходимо соединить глобальной связью. В таких случаях в качестве линии связи используют два маршрутизатора, соединенных по двухточечной схеме (рисунок 5.9). Для вырожденной сети, образованной линией связи, связывающей порты двух смежных маршрутизаторов, приходится выделять отдельный номер сети, хотя в этой сети всего два узла.</p>
<p align="center"><img src="img/chapter5/5.9.jpg"/></p>
<p align="center">Рисунок 5.9 – Нерациональное использование пространства IP-адресов</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для смягчения проблемы дефицита адресов разработчики стека TCP/IP предлагают разные подходы. Принципиальным решением является переход на новую версию протокола IP – протокол IPv6, в котором резко расширяется адресное пространство. Однако и текущая версия протокола IP (IPv4) поддерживает технологии, направленные на более экономное расходование IP-адресов, такие, например, как NAT и CIDR.</p>
</font>
<p align="center">
		<a name="5.3.4.3"><font class="big">5.3.4.3 Адресация и технология CIDR</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Технология бесклассовой междоменной маршрутизации (Classless Inter-Domain Routing, CIDR), которая позволяет центрам распределения адресов избежать выдачи абонентам излишних адресов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Деление IP-адреса на номера сети и узла в технологии CIDR происходит на основе маски переменной длины, назначаемой поставщиком услуг. Непременным условием применимости CIDR является наличие у организации, распоряжающейся адресами, непрерывных диапазонов адресов. Такие адреса имеют одинаковый префикс, то есть одинаковую цифровую последовательность в нескольких старших разрядах.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пусть в распоряжении некоторого поставщика услуг имеется непрерывное пространство IP-адресов в количестве 2n. Отсюда следует, что префикс имеет длину (32-n) разрядов. Оставшиеся n разрядов играют роль счетчика последовательных номеров.</p>
<p align="center"><img src="img/chapter5/5.10.jpg"/></p>
<p align="center">Рисунок 5.10 – Распределение адресов на основе технологии CIDR</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда потребитель обращается к поставщику услуг с просьбой о выделении ему некоторого числа адресов, то в имеющемся пуле адресов "вырезается" непрерывная область S1, S2 или S3, в зависимости от требуемого количества адресов. При этом должны быть выполнены следующие условия:
<ul>
<li>количество адресов в выделяемой области должно быть равно степени двойки,</li>
<li>начальная граница выделяемого пула адресов должна быть кратна требуемому количеству узлов.</li>
</ul>
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Очевидно, что префикс каждой из показанных на рисунке областей имеет собственную длину – чем меньше количество адресов в данной области, тем длиннее ее префикс.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Например, поставщик услуг Интернета располагает пулом адресов в диапазоне 193.20.0.0-193.23.255.255 (1100 0001.0001 0100.0000 0000.0000 00001100 0001.0001.0001 0111. 1111 1111. 1111 1111), то есть количество адресов равно 2<sup>8</sup> . Соответственно префикс поставщика услуг имеет длину 14 разрядов – 1100 0001.0001 01, или в другом виде – 193.20/14.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если абоненту этого поставщика услуг требуется совсем немного адресов, например 13, то поставщик мог бы предложить ему различные варианты: сеть 193.20.30.0/28, сеть 193.20.30.16/28 или сеть 193.21.204.48/28. Во всех случаях в распоряжении абонента для нумерации узлов имеются 4 младших бита. Таким образов, наименьшее число, удовлетворяющее потребностям абонента (13), которое можно представить степенью двойки (2<sup>4</sup>), является 16. Префикс для каждого из выделяемых пулов во всех этих случаях играет роль номера сети, он имеет длину 32-4-28 разрядов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Например, вариант, когда поставщику услуг обратился крупный заказчик, сам, возможно собирающийся оказывать услуги по доступу в Интернет. Ему потребуется блок адресов в 4000 узлов. На нумерацию такого количества узлов уйдет 12 двоичных разрядов, следовательно, размер выделенного пула адресов оказывается несколько больше требуемого – 4096.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Граница, с которой должен начинаться выделяемый участок, должна быть кратна размеру участка, то есть это могут быть любые адреса из следующих: 193.20.0.0, 193.20.16.0, 193.20.32.0, 193.20.48.0 и другие сила оканчивающиеся на 12 нулей. Пусть поставщик  услуг предложил потребителю диапазон адресов 193.20.16.0 -193.20.31.255. Для этого диапазона агрегированный номер сети (префикс) имеет длину 20 двоичных разрядов и равен 193.20.16.0/20.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Благодаря CIDR поставщик услуг получает возможность "нарезать" блоки из выделенного ему адресного пространства в соответствии с действительными требованиями каждого клиента. Технология CIDR помогает не только экономно расходовать адреса, но и более эффективно осуществлять маршрутизацию.</p>
</font>
<p align="center">
		<a name="5.3.4.4"><font class="big">5.3.4.4 Автоматическое назначение IP-адресов</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для нормальной работы сети каждому сетевому интерфейсу компьютера и маршрутизатора должен быть назначен IP-адрес. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Процедура присвоения адресов происходит в ходе конфигурирования компьютеров и маршрутизаторов. Назначение IP-адресов может происходить вручную в результате выполнения процедуры конфигурирования интерфейса, для компьютера сводящейся, например, к заполнению системы экранных форм. При этом администратор должен помнить, какие адреса из имеющегося множества он уже использовал для других интерфейсов, а какие еще свободны. При конфигурировании помимо IP-адресов сетевых интерфейсов (и соответствующих масок) устройству сообщается ряд других конфигурационных параметров. При конфигурировании администратор должен назначить клиенту не только IP-адрес, но и другие параметры стека TCP/IP, необходимые для его эффективной работы, например маску и IP-адрес маршрутизатора по умолчанию, IP-адрес DNS-сервера, доменное имя компьютера и т.п. Даже при не очень большом размере сети эта работа представляет для администратора утомительную процедуру.</p>
</font>
<p align="center">
		<a name="5.3.4.4.1"><font class="big">5.3.4.4.1 Протокол DHCP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол динамического конфигурирования хостов (Dynamic Host Configuration Protocol) автоматизирует процесс конфигурирования сетевых интерфейсов, обеспечивая отсутствие дублирования адресов за счет централизованного управления их распределением.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол DHCP работает в соответствии с моделью клиент-сервер. Во время старта системы компьютер, являющийся DHCP-клиентом, посылает в сеть широковещательный запрос на получение IP-адреса. DHCP-сервер откликается и посылает сообщение-ответ, содержащие IP-адрес и некоторые другие конфигурационные параметры.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При этом сервер DHCP может работать в разных режимах, включая:
<ul>
<li>ручное назначение статических адресов,</li>
<li>автоматическое назначение статических адресов,</li>
<li>автоматическое распределение динамических адресов.</li>
</ul>
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Во всех режимах работы администратор при конфигурировании DHCP-сервера сообщает ему один или несколько диапазонов IP-адресов, причем все эти адреса относятся к одной сети, то есть имеют одно и то же значение в поле номере сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В ручном режиме администратор, помимо пула доступных адресов, снабжает DHCP-сервер информацией о жестком соответствии IP-адресов физическим адресам или другим идентификаторам клиентских узлов. DHCP-сервер, пользуясь этой информацией всегда выдаст определенному DHCP-клиенту один и тот же назначенный ему администратору IP-адрес.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В режиме автоматического назначения статических адресов DHCP-сервер самостоятельно без вмешательства администратора произвольным образом выбирает клиенту IP-адрес из пула наличных IP-адресов. Адрес дается клиенту из пула в постоянное пользование, то есть между идентифицирующей информацией клиента и его IP-адресом по-прежнему, как и при ручном назначении, существует постоянное соответствие. Оно устанавливается в момент первого назначения DHCP-сервером IP-адреса клиенту. При всех последующих запросах сервер возвращает тот же самый IP-адрес.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При динамическом распределении адресов DHCP-сервер выдает адрес клиенту на ограниченное время, называемое сроком аренды. Когда компьютер, являющийся DHCP-клиентом, удаляется из подсети, назначенный ему IP-адрес автоматически освобождается. Когда компьютер подключается к другой подсети, то ему автоматически назначается новый адрес. Ни пользователь, ни сетевой администратор не вмешиваются в этот процесс.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Это дает возможность впоследствии повторно использовать этот IP-адрес для назначения другому компьютеру. Таким образом, помимо основного преимущества DCHP-автоматизации рутинной работы администратора по конфигурированию стека TCP/IP на каждом компьютере, режим динамического распределения адресов в принципе позволяет строить IP-сеть, количество узлов в которой превышает количество имеющихся в распоряжении администратора IP-адресов [Олифер. Компьютерные сети, 2010].</p>
</font>
<p align="center">
		<a name="5.3.4.4.2"><font class="big">5.3.4.4.2 Алгоритм динамического назначения адресов</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Администратор управляет процессом конфигурирования сети, определяя два основных конфигурационных параметра DHCP-сервера: пул адресов, доступных распределению и срок аренды. Срок аренды диктует, как долго компьютер может использовать  назначенный IP-адрес, перед тем, как снова запросит его от DHCP-сервера. Срок аренды зависит от режима работы пользовательской сети. Если это небольшая сеть учебного заведения, куда со своими компьютерами приходят многочисленные студенты для выполнения лабораторных работ, то срок аренды может быть равен длительности лабораторной работы. Если же это корпоративная сеть, в которой сотрудники предприятия работают на регулярной основе, то срок аренды может быть достаточно длительным – несколько дней или даже недель.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DHCP-сервер должен находиться в одной подсети с клиентами, учитывая, что клиенты посылают ему широковещательные запросы (рисунок 5.11). Для снижения риска выхода сети из строя из-за отказа DHCP-сервера в сети иногда ставят резервный DHCP-сервер (такой вариант соответствует сети 1).</p>
<p align="center"><img src="img/chapter5/5.11.jpg"/></p>
<p align="center">Рисунок 5.11 – Схемы взаимного расположения DHCP-серверов и DHCP-клиентов</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Иногда наблюдается и обратная картина: в сети нет ни одного DHCP-сервера. В этом случае его подменяет DHCP-агент – программное обеспечение, играющее роль посредника между DHCP-клиентами и DHCP-серверами (пример такого варианта – сеть 2). Связной агент переправляет запросы клиентов из сети 2 DHCP-серверу сети 3. Таким образом, один DHCP-сервер может обслуживать DYCP-клиентов нескольких разных сетей.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вот так выглядит упрощенная схема обмена сообщениями между клиентскими и серверными частями DHCP:
<ol>
<li>Когда компьютер включают, установленный на нем DHCP-клиент посылает ограниченное широковещательное сообщение DHCP-поиска (IP-пакет с адресом назначения, состоящим из одних единиц, который должен быть доставлен всем узлам данной IP-сети).</li>
<li>Находящиеся в сети DHCP-серверы получают это сообщение. Если в сети DHCP-серверы отсутствуют, то сообщение DHCP-поиска получает связной DHCP-агент. Он пересылает это сообщение в другую, возможно, значительно отстоящую от него сеть DHCP-серверу, IP-адрес которого ему заранее известен.</li>
<li>Все DHCP-серверы, получившие сообщение DHCP-поиска посылают DHCP-клиенту, обратившемуся с запросом, свои DHCP-предложения.  Каждое предложение содержит IP-адрес и другую конфигурационную информацию. DHCP-сервер, находящийся в другой сети, посылает ответ через агента.</li>
<li>DHCP-клиент собирает конфигурационные DHCP-приложения от всех DHCP- серверов. Как правило, он выбирает первое из поступивших предложений и отправляет в сеть широковещательный DHCP-запрос. В этом запросе содержатся идентификационная информация о DHCP-сервере, предложение которого принято, а также значения принятых конфигурационных  параметров.</li>
<li>DHCP-серверы получают DHCP-запрос, и только один выбранный DHCP-сервер посылает положительную DHCP-квитанцию (подтверждение IP-адреса и параметров аренды), а остальные серверы аннулируют свои предложения, в частности возвращают в свои пулы предложенные адреса.</li>
<li>DHCP-клиент получает положительную DHCP-квитанцию и переходит в рабочее состояние.</li>
</ol>
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Время от времени компьютер пытается долго обновить параметры аренды у DHCP-сервера. Первую попытку он делает задолго до истечения срока аренды, обращаясь к тому серверу, от которого получил текущие параметры. Если ответа нет или ответ отрицательный, он через некоторое время снова посылает запрос. Так повторяется несколько раз, и если все попытки получить параметры у того же сервера оказываются безуспешными, клиент обращается к другому серверу. Если и другой сервер отвечает отказом, то клиент теряет свои конфигурационные параметры и переходит в режим автономной работы.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Также DHCP-клиент может по своей инициативе досрочно отказаться от выделенных ему параметров.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В сети, где адреса назначаются динамически нельзя быть уверенным в адресе, который в данный момент имеет тот или иной узел. И такое непостоянство IP-адресов влечет за собой некоторые проблемы.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Во-первых, возникают сложности при преобразовании символьного доменного имени в IP-адрес. Очень проблематично функционирование системы DNS, которая должна поддерживать таблицы соответствия символьных имен IP-адресами в условиях, когда последние меняют каждый два часа. Учитывая это обстоятельство, для серверов, к которым пользователи часто обращаются по символьному имени, назначаются статические IP-адреса, оставляя динамические только для клиентских компьютеров. Однако в некоторых сетях количество серверов на столько велико, что их ручное конфигурирование становится слишком обременительным. Это привело к разработке усовершенствованной версии DNS (так называемой динамической системы DNS), в основе которой лежит согласование информационной адресной базы в службах DHCP и DNS.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Во-вторых, трудно осуществлять удаленное управление и автоматический мониторинг интерфейса (например, сбор статистики). Если в качестве его идентификатора выступает динамически изменяемый IP-адрес.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Наконец, для обеспечения безопасности сети многие сетевые устройства могут блокировать (фильтровать) пакеты, определенные поля которых имеют заранее заданные значения. Другими словами, при динамическом назначении адресов усложняется фильтрация пакетов по IP-адресам.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Последние две проблемы проще всего решаются отказом от динамического назначения адресов для интерфейсов, фигурирующих в системах мониторинга и безопасности [Олифер. Компьютерные сети. Приницы…., 2010].</p>
</font>
<p align="center">
		<a name="5.3.5"><font class="big">5.3.5 Маршрутизация в IP-сетях</font></a>
</p>
<p align="center">
		<a name="5.3.5.1"><font class="big">5.3.5.1 Маршрутизация с использованием масок одинаковой длины</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм маршрутизации усложняется, когда в систему адресации узлов вносятся дополнительные элементы - маски. Одна из причин отказа от хорошо себя зарекомендовавшего в течение многих лет метода адресации, основанного на классах заключается в потребности в структуризации сетей.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Часто администраторы сетей испытывают неудобства из-за того, что количество централизованно выделенных им номеров сетей недостаточно для того, чтобы структурировать сеть надлежащим образом, например разместить все слабо взаимодействующие компьютеры по разным сетям. В такой ситуации возможны два пути. Первый из них связан с получением от поставщика услуг Интернет дополнительных номеров сетей. Второй способ, употребляющийся чаще, связан с использованием технологии масок, которая позволяет разделять одну сеть на несколько сетей.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Допустим, администратор получил в свое распоряжение адрес класса В: 129.44.0.0. Он может организовать сеть с большим числом узлов, номера которых он может брать из диапазона 0.0.0.1- 0.0.255.254. Всего в его распоряжении имеется (216-2) адреса. Вычитание двойки связано с учетом того, что адреса из одних нулей и одних единиц имеют специальное назначение и не годятся для адресации узлов. Однако ему не нужна одна большая неструктурированная сеть. Производственная необходимость диктует администратору другое решение, в соответствии с которым сеть должна быть разделена на три отдельных подсети, при этом трафик в каждой подсети должен быть надежно локализован. Это позволит легче диагностировать сеть и проводить в каждой из подсетей особую политику безопасности.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что разделение большой сети с помощью масок имеет еще одно преимущество – оно позволяет скрыть внутреннюю структуру сети предприятия от внешнего наблюдателя и тем самым повысить ее безопасность. Далее представлено, как решается эта проблема путем использования механизма масок.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.13 показано разделение всего полученного администратором адресного пространства на четыре равные части – каждая по 214  адресов. При этом число разрядов, доступных для нумерации узлов изменилось на два бита, а префикс (номер) каждой из четырех сетей стал длиннее на два бита. Следовательно, каждый из четырех диапазонов можно написать в виде адреса с маской, состоящей из 18 единиц, или в десятичной нотации 255.255.192.0. </p>
<p style="text-align:center">129.44.0.0/18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(10000001 00101100 <strong>00</strong>000000 00000000)<br>
129.44.64.0/18&nbsp;&nbsp;&nbsp;(10000001 00101100 <strong>01</strong>000000 00000000)<br>
129.44.128.0/18&nbsp;(10000001 00101100 <strong>10</strong>000000 00000000)<br>
129.44.192.0/18&nbsp;&nbsp;(10000001 00101100 <strong>11</strong>000000 00000000) </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Из приведенных записей видно, что администратор получает возможность использовать для нумерации подсетей два дополнительных бита (выделенных жирным шрифтом). Именно это позволяет ему из одной централизованно выделенной сети четыре, в данном примере это 129.44.0.0/18, 129.44.64.0/18, 129.44.128.0/18, 129.44.192.0/18.</p>
<p align="center"><img src="img/chapter5/5.12.jpg"/></p>
<p align="center">Рисунок 5.12 – Разделение адресного пространства 129.44.0.0. сети класса В на четыре равные части</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пример сети, построенной путем деления на четыре сети равного размера, представлен на рисунке 5.13. Весь трафик во внутреннюю сеть 129.44.0.0, направляемый из внешней сети, поступает через маршрутизатор M1. В целях структуризации информационных потоков  во внутренней сети установлен дополнительный маршрутизатор М2. Каждая из вновь образованных сетей 129.44.0.0/18, 129.44.64.0/18 и 129.44.128.0/18 и маски одинаковой длины - 255.255.192.0 подключена к соответственно сконфигурированным портам внутреннего маршрутизатора М2. Кроме того, в одной из этих сетей (номер 129.44.192.0, маска 255.255.192.0), выделенной для организации соединения между внешними и внутренними маршрутизаторами, для адресации узлов задействованы два адреса - 129.44.192.1 (порт маршрутизатора М2) и 129.44.192.2 (порт маршрутизатора M1).</p>
<p align="center"><img src="img/chapter5/5.13.jpg"/></p>
<p align="center">Рисунок 5.13 – Маршрутизация с использованием масок одной длины</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Извне сеть по-прежнему выглядит, как единая сеть класса В, а на местном уровне это полноценная составная сеть, в которую входят три отдельные сети. Поступающий общий трафик разделяется локальным маршрутизатором М2 между четырьмя сетями. В условиях, когда механизм классов не действует, маршрутизатор должен иметь другое средство, которое позволило бы ему определять, какая часть 32-разрядного числа, помещенного в поле адреса назначения, является номером сети. Именно этой цели служит дополнительное поле маски, включенное в таблицу маршрутизации в соответствии с таблицей маршрутизации (таблица 5.2).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Первые четыре записи в таблице соответствуют внутренним подсетям, непосредственно подключенным к портам маршрутизатора М2. Запись 0.0.0.0 с маской 0.0.0.0 соответствует маршруту по умолчанию. Последняя запись определяет специфический маршрут к узлу 129.44.128.15. В тех строках таблицы, в которых в качестве адреса назначения указан полный IP-адреса узла, маска имеет значение 255.255.255.255. В отличие от всех других узлов сети 129.44.128.0, к которым пакеты поступают с интерфейса 129.44.128.5 маршрутизатора М2, к данному узлу они должны приходить через маршрутизатор М3</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.2 – Таблица маршрутизатора М2 в сети с масками одинаковой длины.</p>
<table align="center" border="1">
	<tr>
    	<td>Адрес назначения</td>
        <td>Маска</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Адрес порта</td>
        <td>Расстояние</td>
    </tr>
    <tr>
    	<td>129.44.0.0</td>
        <td>255.255.192.0</td>
        <td>129.44.0.1</td>
        <td>129.44.0.1</td>
        <td>Подключена</td>
    </tr>
    <tr>
    	<td>129.44.64.0</td>
        <td>255.255.192.0</td>
        <td>129.44.64.7</td>
        <td>129.44.64.7</td>
        <td>Подключена</td>
    </tr>
    <tr>
    	<td>129.44.128.0</td>
        <td>255.255.192.0</td>
        <td>129.44.128.5</td>
        <td>129.44.128.5</td>
        <td>Подключена</td>
    </tr>
    <tr>
    	<td>129.44.192.0</td>
        <td>255.255.192.0</td>
        <td>129.44.192.1</td>
        <td>129.44.192.1</td>
        <td>Подключена</td>
    </tr>
    <tr>
    	<td>0.0.0.0</td>
        <td>0.0.0.0</td>
        <td>129.44.192.2</td>
        <td>129.44.192.1</td>
        <td>-</td>
    </tr>
    <tr>
    	<td>129.44.128.15</td>
        <td>255.255.255.255</td>
        <td>129.44.64.8</td>
        <td>129.44.64.7</td>
        <td>-</td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм просмотра таблиц маршрутизации, содержащих маски, имеет много общего с описанным алгоритмом просмотра таблиц не содержащих маски. Однако в нем имеются и существенные изменения.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 Поиск следующего маршрутизатора для вновь поступившего IP-пакета протокол начинает с того, что извлекает из пакета адрес назначения (обозначенного IPD). Затем протокол IP приступает к процедуре просмотра таблицы маршрутизации, также состоящей из двух фаз, как и процедура просмотра таблицы маршрутизации, в которой столбец маски отсутствует.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 Первая фаза состоит в поиске специфического маршрута для адреса IP<sub>D</sub>. С этой целью из каждой записи таблицы, в которой маска имеет значение 255.255.255.255, извлекается адрес назначения и сравнивается с адресом из пакета IP<sub>D</sub>.  Если в какой либо строке совпадение произошло, то адрес следующего маршрутизатора для данного пакета берется из данной строки.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 Вторая фаза выполняется только в том случае, если во время первой фазы не произошло совпадения адресов. Она состоит в поиске неспецифического маршрута, общего для группы узлов, к которой относится и пакет с адресом IPD. Для этого средствами IP заново просматривается таблица маршрутизации, причем с каждой записью производятся следующие действия:
<ol type="a">
<li>маска (М), содержащаяся в данной записи, "накладывается" на IP-адрес узла назначения IP<sub>D</sub>, извлеченный из пакета: IP<sub>D</sub>  AND M;</li>
<li>полученное в результате число сравнивается со значением, которое помещено поле адреса назначения той же записи таблицы  маршрутизации;</li>
<li>если происходит совпадение, протокол IP соответствующим образом отмечает эту строку;</li>
<li>если просмотрены не все строки, то протокол IP аналогичным образом просматривает следующую строку, если все (включая строку о маршрутизаторе по умолчанию), то просмотр записей заканчивается, и происходит переход к следующему шагу.</li>
</ol>
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После просмотра все таблицы маршрутизатор выполняет одно из трех действий:
<ol type="a">
<li>если не произошло ни одного совпадения и маршрут по умолчанию отсутствует, то пакет отбрасывается,</li>
<li>если произошло одно совпадение, то пакет отправляется по маршруту, указанному в строке с совпавшим адресом,</li>
<li>если произошло несколько совпадений, то все помеченные строки сравниваются и выбирается маршрут из той строки, в которой количество совпавших двоичных разрядов наибольшее (другими словами, в ситуации, когда адрес назначения пакета принадлежит сразу нескольким подсетям, маршрутизатор использует наиболее специфический маршрут).</li>
</ol></p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее проиллюстрирована работа, как маршрутизатор М2 (рисунок 5.14) использует описанный алгоритм для работы со своей таблицей маршрутизации (таблица 5.2). Пусть на маршрутизатор М2 поступает пакет с адресом назначения 129.44.78.200. Модуль IP, установленный на этом маршрутизаторе, прежде всего, сравнит этот адрес с адресом 129.44.128.15, для которого определен специфический маршрут. Совпадения нет, поэтому модуль IP начинает последовательно обрабатывать все строки таблицы, накладывая маски и сравнивая результаты до тех пор, пока не найдет совпадения номера сети в адресе назначения и в строке таблицы. В результате определяется маршрут для пакета 129.44.78.200 – он должен быть отправлен на выходной порт маршрутизатора 129.44.64.7 в сеть 129.44.64.0, непосредственно подключенной к данному маршрутизатору.</p>
</font>
<p align="center">
		<a name="5.3.5.2"><font class="big">5.3.5.2 Использование масок переменной длины</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Во многих случаях более эффективным является разбиение сети на подсети разного размера. В частности, для подсети, которая связывает два маршрутизатора по двухточечной схеме, даже количество адресов класса С явно является избыточным.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.14 приведен другой пример распределения того же адресного пространства 129.44.0.0/16, что и в предыдущем примере. Здесь половина из имеющихся адресов (2<sup>15</sup>) отведена для создания сети 1, имеющей адрес 129.44.0.0 и маску 255.255.128.0.</p>
<p align="center"><img src="img/chapter5/5.14.jpg"/></p>
<p align="center">Рисунок 5.14 – Разделение адресного пространства 129.44.0.0 сети класса В на сети разного размера путем использования масок переменной длины</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Следующая порция адресов, составляющая четверть всего адресного пространства (2<sup>14</sup>) предназначена для сети 2 – 129.44.128.0 с маской 255.255.192.0. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее в пространстве адресов был "нарезан" небольшой фрагмент для создания вспомогательной сети 3, предназначенной для связывания внутреннего маршрутизатора с внешним маршрутизатором М1. Для нумерации узлов в такой вырожденной сети достаточно ввести два двоичных разряда. Из четырех возможных комбинаций номеров узлов 00, 01,10 и 11 два номера имеют специальное назначение и не могут быть присвоены узлам, но оставшиеся два 10 и 01 позволяют адресовать порты маршрутизаторов. Поле номера узла в таком случае имеет два двоичных разряда, маска в десятичной нотации имеет номер 255.255.255.252, а номер сети, как видно из рисунка, равен 129.44.192.0.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что глобальным связям между маршрутизаторами, соединенными по двух точечной схеме, не обязательно давать IP-адреса. Однако чаще всего такой вырожденной сети все же дают IP-адрес. Помимо прочего, это делается, например, для того, чтобы скрыть внутреннюю структуру сети и обращаться к ней по одному по одному адресу входного порта маршрутизатора, в данном примере по адресу 129.44.192.1, применяя технику трансляции сетевых адресов (Network Address Translation, NAT).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Оставшееся адресное пространство администратор может "нарезать" на разное количество сетей разного объема в зависимости от своих потребностей. Из оставшегося пула (2<sup>14</sup>-4) адресов администратор, например может образовать еще одну достаточно большую сеть с числом узлов 2<sup>13</sup> - на рисунке это сеть 4. при этом свободными останутся почти столько же адресов (2<sup>13</sup>-4), которые также могут быть использованы для создания новых сетей. К примеру, их этого "остатка" можно образовать 31 сеть, каждая из которых равна размеру сети класса С, и к тому же еще несколько сетей меньшего размера. Ясно, что разбиение может быть другим, но в любом случае с помощью масок переменного размера администратор имеет больше возможностей рационально использовать все имеющиеся у него адреса.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.15 показан пример сети, структурированной с помощью масок переменной длины.</p>
<p align="center"><img src="img/chapter5/5.15.jpg"/></p>
<p align="center">Рисунок 5.15 – Структуризация сети масками переменной длины</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В таблице 5.3 представлена таблица маршрутизации маршрутизатора М2, который обрабатывает поступившие на его интерфейсы пакеты.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.3 – Таблица маршрутизатора М2 в сети с масками переменной длины</p>
<table align="center" border="1">
	<tr>
    	<td>Адрес назначения</td>
        <td>Маска</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Адрес порта</td>
        <td>Расстояние</td>
    </tr>
    <tr>
    	<td>129.44.0.0</td>
        <td>255.255.128.0</td>
        <td>129.44.128.3</td>
        <td>129.44.128.1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>129.44.128.0</td>
        <td>255.255.192.0</td>
        <td>129.44.128.1</td>
        <td>129.44.128.1</td>
        <td>Подключена</td>
    </tr>
    <tr>
    	<td>129.44.192.0</td>
        <td>255.255.255.252</td>
        <td>129.44.192.1</td>
        <td>129.44.192.1</td>
        <td>Подключена</td>
    </tr>
    <tr>
    	<td>129.44.224.0</td>
        <td>255.255.224.0</td>
        <td>129.44.128.2</td>
        <td>129.44.128.1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>0.0.0.0</td>
        <td>0.0.0.0</td>
        <td>129.44.192.2</td>
        <td>129.44.192.1</td>
        <td>-</td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пусть поступивший на М2 пакет имеет адрес назначения 129.44.162.5. Поскольку специфические маршруты в таблице отсутствуют, маршрутизатор переходит ко второй фазе – фазе последовательного анализа строк на предмет поиска совпадения с адресом назначения.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	(129.44.162.5) AND (255.255.128.0) = 129.44.128.0 – нет совпадения,</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- (129.44.162.5) AND (255.255.192.0) = 129.44.128.0 – совпадение,</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- (129.44.162.5) AND (255.255.255.252) = 129.44.162.4 – нет совпадения,</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- (129.44.162.5) AND (255.255.224.0) = 129.44.160.0 – нет совпадения.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таким образом, совпадение имеет место в одной строке. Пакет будет отправлен в непосредственно подключенную к данному маршрутизатору сеть на выходной интерфейс 129.44.128.1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если пакет с адресом 129.44.192.1 поступает из внешней сети и маршрутизатор М1 не использует маски, пакет передается маршрутизатору М2, а потом снова возвращается в соединительную сеть. Очевидно, что такие передачи пакета не выглядят рациональными.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Маршрутизация будет более эффективной, если в таблице маршрутизации маршрутизатора М1 задать маршруты масками переменной длины (таблица 5.4). Первая из приведенных двух записей говорит о том, что все пакеты. Адреса которых начинаются с 129.44, должны быть переданы на маршрутизатор М2. Эта запись выполняет агрегирование адресов всех подсетей, созданных на базе сети 129.44.0.0. Вторая строка  говорит о том, что среди всех возможных подсетей сети 129.44.0.0. есть одна (129.44.192.0/30), которой пакеты можно направлять непосредственно, а не через маршрутизатор М2.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что в IP-пакетах, при использовании механизма масок по-прежнему передается только IP-адрес назначения, а маска сети назначения не передается. Поэтому из IP-адреса пришедшего пакета невозможно выяснить, какая часть относится к номеру сети, а какая -  к номеру узла. Если маски во всех подсетях имеют один размер, то это не создает проблем. Если же для образования подсетей применяют маски переменной длины, то маршрутизатор должен как-то узнать, каким адресам сетей какие маски соответствуют. Для этого используются протоколы маршрутизации, переносящие между маршрутизаторами не только служебную информацию об адресах сетей, но и о масках, соответствующих этим номерам. К таким протоколам относятся протоколы RIPv2 и OSPF, а протокол RIPv1 маски не переносит и для маршрутизации на основе масок переменной длины не подходит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.4 – Фрагмент таблицы маршрутизатора М1</p>
<table align="center" border="1">
	<tr>
    	<td>Адрес назначения</td>
        <td>Маска</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Адрес порта</td>
        <td>Расстояние</td>
    </tr>
    <tr>
    	<td>129.44.0.0</td>
        <td>255.255.0.0</td>
        <td>129.44.192.1</td>
        <td>129.44.191.2</td>
        <td>2</td>
    </tr>
    <tr>
    	<td>129.44.192.0</td>
        <td>255.255.255.192</td>
        <td>129.44.192.2</td>
        <td>129.44.192.2</td>
        <td>Подключена</td>
    </tr>
</table>
</font>
<p align="center">
		<a name="5.3.6"><font class="big">5.3.6 Таблицы маршрутизации в IP-сетях</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Программные модули протокола IP устанавливаются на всех конечных станциях и маршрутизаторах сети. Для продвижения пакетов они используют таблицы маршрутизации.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Структура таблицы маршрутизации стека TCP/IP соответствует общим принципам построения таблиц маршрутизации, рассмотренным выше. Однако важно отметить, что вид таблицы IP-маршрутизации зависит от конкретной реализации стека TCP/IP. Приведем пример трех вариантов таблицы маршрутизации, с которыми мог бы работать маршрутизатор M1 в сети, представленной на рисунок 5.16.</p>
<p align="center"><img src="img/chapter5/5.16.jpg"/></p>
<p align="center">Рисунок 5.16 – Пример маршрутизируемой сети</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если представить, что в качестве маршрутизатора в данной сети работает штатный программный маршрутизатор MPR операционной системы Microsoft Windows NT, то его таблица маршрутизации могла бы иметь следующий вид (таблица 5.5).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.5 – Таблица программного маршрутизатора MPR Windows NT</p>
<table align="center" border="1">
	<tr>
    	<td>Network Address</td>
        <td>Netmask</td>
        <td>Gateway Address</td>
        <td>Interface</td>
        <td>Metric</td>
    </tr>
    <tr>
    	<td>127.0.0.0</td>
        <td>255.0.0.0</td>
        <td>127.0.0.1</td>
        <td>127.0.0.1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>0.0.0.0</td>
        <td>0.0.0.0</td>
        <td>198.21.17.7</td>
        <td>198.21.17.5</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>56.0.0.0</td>
        <td>255.0.0.0</td>
        <td>213.34.12.4</td>
        <td>213.34.12.3</td>
        <td>15</td>
    </tr>
    <tr>
    	<td>116.0.0.0</td>
        <td>255.0.0.0</td>
        <td>213.34.12.4</td>
        <td>213.34.12.3</td>
        <td>13</td>
    </tr>
    <tr>
    	<td>129.13.0.0</td>
        <td>255.255.0.0</td>
        <td>198.21.17.6</td>
        <td>198.21.17.5</td>
        <td>2</td>
    </tr>
    <tr>
    	<td>198.21.17.0</td>
        <td>255.255.255.0</td>
        <td>198.21.17.5</td>
        <td>198.21.17.5</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>213.34.12.0</td>
        <td>255.255.255.0</td>
        <td>213.34.12.3</td>
        <td>213.34.12.3</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>224.0.0.0</td>
        <td>224.0.0.0</td>
        <td>198.21.17.6</td>
        <td>198.21.17.6</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>224.0.0.0</td>
        <td>224.0.0.0</td>
        <td>213.34.12.3</td>
        <td>213.34.12.3</td>
        <td>1</td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Здесь поле "Network Address" означается адрес сети назначения, поле "Netmask" означает маску сети, поле "Gateway Address" означает адрес следующего маршрутизатора, поле "Interface" означает адрес порта, с которого нужно отправить пакет, поле "Metric" означает признак непосредственно подключенной сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если на месте маршрутизатора установить аппаратный маршрутизатор NetBuilder II компании 3 Com, то его таблица маршрутизации для этой же сети может выглядеть так, как показано в таблице 5.6.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.6 – Таблица маршрутизации маршрутизатора NetBuilder II</p>
<table align="center" border="1">
	<tr>
    	<td>Destination</td>
        <td>Mask</td>
        <td>Gateway</td>
        <td>Metric</td>
        <td>Status</td>
        <td>TTL</td>
        <td>Source</td>
    </tr>
    <tr>
    	<td>198.21.17.0</td>
        <td>213.34.12.0</td>
        <td>255.255.255.0</td>
        <td>0</td>
        <td>Up</td>
        <td>–</td>
        <td>Connected</td>
    </tr>
    <tr>
    	<td>213.34.12.0</td>
        <td>255.255.255.0</td>
        <td>213.34.12.3</td>
        <td>0</td>
        <td>Up</td>
        <td>-</td>
        <td>Connected</td>
    </tr>
    <tr>
    	<td>56.0.0.0</td>
        <td>255.0.0.0</td>
        <td>213.34.12.4</td>
        <td>14</td>
        <td>Up</td>
        <td>-</td>
        <td>Static</td>
    </tr>
    <tr>
    	<td>116.0.0.0</td>
        <td>255.0.0.0</td>
        <td>213.34.12.4</td>
        <td>12</td>
        <td>Up</td>
        <td>-</td>
        <td>Static</td>
    </tr>
    <tr>
    	<td>129.13.0.0</td>
        <td>255.255.0.0</td>
        <td>198.21.17.6</td>
        <td>1</td>
        <td>Up</td>
        <td>160</td>
        <td>RIP</td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Здесь поле "Destination" означает IP-адрес сети назначения,  поле "Mask" означает маску сети, поле "Gateway" означает  IP-адрес порта следующего маршрутизатора, по направлению движения к сети назначения, поле "Metric" означает признак непосредственно подключенной сети, поле "Status" показывает, что маршрутизатор активен и работоспособен, если ему присвоено значение "Up", поле "TTL" (Time to live) означает время жизни пакета, измеряется в секундах, поле "Source" отражает источник появления записи в таблице маршрутизации.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В таблице 5.7 представлен другой вид таблицы маршрутизации. Она составлена для маршрутизатора, реализованного в виде программного маршрутизатора одной из версий операционной системы Unix.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Здесь поле "Destination" означает IP-адрес сети назначения, поле "Gateway" означает адрес следующего маршрутизатора, поле "Flags" означает флаги записей (U - показывает, что маршрут активен и работоспособен, Н - признак специфического маршрута к определенному хосту, G - означает, что маршрут пакета проходит через промежуточный маршрутизатор, отсутствие этого флага отмечает непосредственно подключенную сеть, D - означает, что маршрут получен из сообщения Redirect - перенаправление протокола ICMP),  поле "Refcnt" показывает, сколько раз на данный маршрут ссылались при продвижении пакетов, поле "Use" отражает количество пакетов, переданных по данному маршруту, поле "Interface" означает адрес порта, с которого нужно отправить пакет.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.7 – Таблица маршрутизации Unix-маршрутизатора</p>
<table align="center" border="1">
	<tr>
		<td>Destination</td>
		<td>Gateway</td>
		<td>Flags</td>
		<td>Refcnt</td>
		<td>Use</td>
		<td>Interface</td>
	</tr>
    <tr>
		<td>127.0.0.0</td>
		<td>127.0.0.1</td>
		<td>UH</td>
		<td>1</td>
		<td>154</td>
		<td>le0</td>
	</tr>
    <tr>
		<td>Default</td>
		<td>198.21.17.7</td>
		<td>UG</td>
		<td>5</td>
		<td>43270</td>
		<td>le0</td>
	</tr>
    <tr>
		<td>198.21.17.0</td>
		<td>198.21.17.5</td>
		<td>U</td>
		<td>35</td>
		<td>246876</td>
		<td>le0</td>
	</tr>
    <tr>
		<td>213.34.12.0</td>
		<td>213.34.12.3</td>
		<td>U</td>
		<td>44</td>
		<td>132435</td>
		<td>le1</td>
	</tr>
    <tr>
		<td>129.13.0.0</td>
		<td>198.21.17.6</td>
		<td>UG</td>
		<td>6</td>
		<td>16450</td>
		<td>le0</td>
	</tr>
    <tr>
		<td>56.0.0.0</td>
		<td>213.34.12.4</td>
		<td>UG</td>
		<td>12</td>
		<td>5764</td>
		<td>le1</td>
	</tr>
    <tr>
		<td>116.0.0.0</td>
		<td>56.0.0.0</td>
		<td>UG</td>
		<td>21</td>
		<td>23544</td>
		<td>le1</td>
	</tr>
</table>
</font>
<p align="center">
		<a name="5.3.6.1"><font class="big">5.3.6.1 Назначение полей таблицы маршрутизации</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Несмотря на достаточно заметные внешние различия, во всех трех таблицах есть все те ключевые параметры, необходимые для работы маршрутизатора, которые были рассмотрены ранее при обсуждении концепции маршрутизации.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;К таким параметрам, безусловно, относятся адрес сети назначения (столбцы "Destination" в маршрутизаторах NetBuilder и Unix или "Network Address" в маршрутизаторе MPR) и адрес следующего маршрутизатора (столбцы "Gateway" в маршрутизаторах NetBuilder и Unix или "Gateway Address" в маршрутизаторе MPR).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Третий ключевой параметр - адрес порта, на который нужно направить пакет, в некоторых таблицах указывается прямо (поле "Interface" в таблице Windows NT), а в некоторых - косвенно. Так, в таблице Unix-маршрутизатора вместо адреса порта задается его условное наименование - 1е0 для порта с адресом 198.21.17.5, le1 для порта с адресом 213.34.12.3 и 1e0 для внутреннего порта с адресом 127.0.0.1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В маршрутизаторе NetBuilder II поле, обозначающее выходной порт в какой-либо форме, вообще отсутствует. Это объясняется тем, что адрес выходного порта всегда можно косвенно определить по адресу следующего маршрутизатора. Например, попробуем определить по табл. 5.7 адрес выходного порта для сети 56.0.0.0. Из таблицы следует, что следующим маршрутизатором для этой сети будет маршрутизатор с адресом 213.34.12.4. Адрес следующего маршрутизатора должен принадлежать одной из непосредственно присоединенных к маршрутизатору сетей, и в данном случае это сеть 213.34.12.0. Маршрутизатор имеет порт, присоединенный к этой сети, и адрес этого порта 213.34.12.3 мы находим в поле «Gateway» второй строки таблицы маршрутизации, которая описывает непосредственно присоединенную сеть 213.34.12.0. Для непосредственно присоединенных сетей адресом следующего маршрутизатора всегда является адрес собственного порта маршрутизатора. Таким образом, адрес выходного порта для сети 56.0.0 - это адрес 213.34.12.3.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Остальные параметры, которые можно найти в представленных версиях таблицы маршрутизации, являются необязательными для принятия решения о пути следования пакета.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Наличие или отсутствие поля маски в таблице говорит о том, насколько современен данный маршрутизатор. Стандартным решением сегодня является использование поля маски в каждой записи таблицы, как это сделано в таблицах маршрутизаторов MPR Windows NT (поле "Netmask") и NetBuilder (поле "Mask"). Обработка масок при принятии решения маршрутизаторами будет рассмотрена ниже. Отсутствие поля маски говорит о том, что либо маршрутизатор рассчитан на работу только с тремя стандартными классами адресов, либо он использует для всех записей одну и ту же маску, что снижает гибкость маршрутизации.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Метрика, как видно из примера таблицы Unix-маршрутизатора, является необязательным параметром. В остальных двух таблицах это поле имеется, однако оно используется только в качестве признака непосредственно подключенной сети. Действительно, если в таблице маршрутизации каждая сеть назначения упомянута только один раз, то поле метрики не будет приниматься во внимание при выборе маршрута, так как выбор отсутствует. А вот признак непосредственно подключенной сети маршрутизатору нужен, поскольку пакет для этой сети обрабатывается особым способом - он не передается следующему маршрутизатору, а отправляется узлу назначения. Поэтому метрика 0 для маршрутизатора NetBuilder или 1 для маршрутизатора MPR просто говорит маршрутизатору, что эта сеть непосредственно подключена к его порту, а другое значение метрики соответствует удаленной сети. Выбор значения метрики для непосредственно подключенной сети является достаточно произвольным, главное, чтобы метрика удаленной сети отсчитывалась с учетом этого выбранного начального значения. В Unix-маршрутизаторе используется поле признаков, где флаг G отмечает удаленную сеть, а его отсутствие - непосредственно подключенную.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Однако существуют ситуации, когда маршрутизатор должен обязательно хранить значение метрики для записи о каждой удаленной сети. Эти ситуации возникают, когда записи в таблице маршрутизации являются результатом работы некоторых протоколов маршрутизации, например протокола RIP. В таких протоколах новая информация о какой-либо удаленной сети сравнивается с имеющейся в таблице, и если метрика новой информации лучше имеющейся, то новая запись вытесняет имеющуюся. В таблице Unix-маршрутизатора поле метрики отсутствует, и это значит, что он не использует протокол RIP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Флаги записей присутствуют только в таблице Unix-маршрутизатора. Они описывают характеристики записи.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	U - показывает, что маршрут активен и работоспособен. Аналогичный смысл имеет поле "Status" в маршрутизаторе NetBuilder.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	Н - признак специфического маршрута к определенному хосту. Маршрут ко всей сети, к которой принадлежит данный хост, может отличаться от данного маршрута.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	G - означает, что маршрут пакета проходит через промежуточный маршрутизатор (gateway). Отсутствие этого флага отмечает непосредственно подключенную сеть.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	D - означает, что маршрут получен из сообщения Redirect (перенаправление) протокола ICMP. Этот признак может присутствовать только в таблице маршрутизации конечного узла. Признак означает, что конечный узел в какой-то предыдущей передаче пакета выбрал не самый рациональный следующий маршрутизатор на пути к данной сети, и этот маршрутизатор с помощью протокола ICMP сообщил, что все последующие пакеты к данной сети нужно отправлять через другой следующий маршрутизатор. Протокол ICMP может посылать сообщения только узлу-отправителю, поэтому у промежуточного маршрутизатора этот признак встретиться не может. Признак никак не влияет на процесс маршрутизации, он только указывает администратору источник появления записи. В таблице Unix-маршрутизатора используются еще два поля, имеющих справочное значение. Поле "Refcnt" показывает, сколько раз на данный маршрут ссылались при продвижении пакетов. Поле "Use" отражает количество пакетов, переданных по данному маршруту.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В таблице маршрутизатора NetBuilder также имеются два справочных поля. Поле времени жизни "TTL" (Time To Live) имеет смысл для динамических записей, которые имеют ограниченный срок жизни. Текущее значение поля показывает оставшийся срок жизни записи в секундах. Поле "Source" отражает источник появления записи в таблице маршрутизации. Хотя это поле имеется не во всех маршрутизаторах, но практически для всех маршрутизаторов существуют три основных источника появления записи в таблице.</p>
</font>
<p align="center">
		<a name="5.3.6.2"><font class="big">5.3.6.1 Назначение полей таблицы маршрутизации</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Первым источником является программное обеспечение стека TCP/IP. При инициализации маршрутизатора это программное обеспечение автоматически заносит в таблицу несколько записей, в результате чего создается так называемая <em>минимальная таблица маршрутизации</em>.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Это, во-первых, записи о непосредственно подключенных сетях и маршрутизаторах по умолчанию, информация о которых появляется в стеке при ручном конфигурировании интерфейсов компьютера или маршрутизатора. К таким записям в приведенных примерах относятся записи о сетях 213.34.12.0 и 198.21.17.0, а также запись о маршрутизаторе по умолчанию - default в Unix-маршрутизаторе и 0.0.0.0 в маршрутизаторе MPR Windows NT, В приведенном примере таблицы для маршрутизатора NetBuilder маршрутизатор по умолчанию не используется, следовательно, при поступлении пакета с адресом назначения, отсутствующим в таблице маршрутизации, этот пакет будет отброшен.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Во-вторых, программное обеспечение автоматически заносит в таблицу маршрутизации записи об адресах особого назначения. В приведенных примерах таблица маршрутизатора MPR Windows NT содержит наиболее полный набор записей такого рода. Несколько записей в этой таблице связаны с особым адресом 127.0.0.0 (loopback), который используется для локального тестирования стека TCP/IP. Пакеты, направленные в сеть с номером 127.0.0.0, не передаются протоколом IP на канальный уровень для последующей передачи в сеть, а возвращаются в источник - локальный модуль IP. Записи с адресом 224.0.0.0 требуются для обработки групповых адресов (multicast address). Кроме того, в таблицу могут быть занесены адреса, предназначенные для обработки широковещательных рассылок (например, записи 8 и 11 содержат адрес отправки широковещательного сообщения в соответствующих подсетях, а последняя запись в таблице - адрес ограниченной широковещательной рассылки сообщения). Заметим, что в некоторых таблицах записи об особых адресах вообще отсутствуют.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вторым источником появления записи в таблице является администратор, непосредственно формирующий запись с помощью некоторой системной утилиты, например программы route, имеющейся в операционных системах Unix и Windows NT. В аппаратных маршрутизаторах также всегда имеется команда для ручного задания записей таблицы маршрутизации. Заданные вручную записи всегда являются статическими, то есть не имеют срока истечения жизни. Эти записи могут быть как постоянными, то есть сохраняющимися при перезагрузке маршрутизатора, так и временными, хранящимися в таблице только до выключения устройства. Часто администратор вручную заносит запись default о маршрутизаторе по умолчанию. Таким же образом в таблицу маршрутизации может быть внесена запись о специфичном для узла маршруте. Специфичный для узла маршрут содержит вместо номера сети полный IP-адрес, то есть адрес, имеющий ненулевую информацию не только в поле номера сети, но и в поле номера узла. Предполагается, что для такого конечного узла маршрут должен выбираться не так, как для всех остальных узлов сети, к которой он относится. В случае, когда в таблице есть разные записи о продвижении пакетов для всей сети и ее отдельного узла, при поступлении пакета, адресованного узлу, маршрутизатор отдаст предпочтение записи с полным адресом узла.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И наконец, третьим источником записей могут быть протоколы маршрутизации, такие как RIP или OSPF. Такие записи всегда являются динамическими, то есть имеют ограниченный срок жизни. Программные маршрутизаторы Windows NT и Unix не показывают источник появления той или иной записи в таблице, а маршрутизатор NetBuilder использует для этой цели поле "Source". В приведенном примере первые две записи созданы программным обеспечением стека на основании данных о конфигурации портов маршрутизатора - это показывает признак "Connected". Следующие две записи обозначены как "Static", что указывает на то, что их ввел вручную администратор. Последняя запись является следствием работы протокола RIP, поэтому в ее поле "TTL" имеется значение 160.</p>
</font>
<p align="center">
		<a name="5.3.7"><font class="big">5.3.7 Маршрутонезависимые протоколы сетевого уровня </font></a>
</p>
<p align="center">
		<a name="5.3.7.1"><font class="big">5.3.7.1 Протокол ICMP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол межсетевых управляющих сообщений (Internet Control Message Protocol) является вспомогательным протоколом, использующимся для диагностики и мониторинга сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Существует ряд ситуаций, когда протокол IP не может доставить пакет адресату, например, когда истекает время жизни пакета, в таблице маршрутизации отсутствует маршрут к заданному в пакете адресу назначения, пакет не проходит проверку по контрольной сумме, шлюз не имеет достаточно места в своем буфере для передачи какого-либо пакета и т. д.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол IP доставляет данные, руководствуясь принципом "по возможности", то есть не принимает мер для гарантированной передачи данных адресату. Это свойство "необязательности" протокола IP компенсируется протоколами более высоких уровней стека TCP/IP, например TCP на транспортном уровне и в какой-то степени DNS на прикладном уровне. Они берут на себя обязанности по обеспечению надежности, применяя такие известные приемы, как нумерация пакетов, подтверждение доставки, повторная посылка данных [Олифер, Компьютерные сети 2010].</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол ICMP также служит дополнением, компенсирующим ненадежность протокола IP, но несколько другого рода. Он не предназначен для исправления возникших при передаче пакета проблем: если пакет потерян, ICMP не может послать его заново. Задача ICMP другая – он является средством оповещения отправителя о "несчастных" случаях, произошедших с пакетами. Например, протокол IP, работающий на каком либо маршрутизаторе обнаружил, что пакет для дальнейшей передачи по маршруту необходимо фрагментировать, но в пакете установлен флаг  DF (не фрагментировать). Протокол IP, обнаруживший что не может передать IP-пакет далее по сети, прежде чем отбросить пакет, должен отправить диагностическое IMCP-сообщение конченому узлу-источнику.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для передачи по сети ICMP-сообщение инкапсулируется в поле данных IP-пакета. IP-адрес узла-источника определяется из заголовка пакета, вызвавшего инцидент.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сообщение, прибывшее в узел-источник, может быть обработано там либо ядром операционной системы, либо протоколами транспортного и прикладного уровней, либо приложениями, либо просто проигнорированы. При этом, обработка ICMP-сообщений не входит в обязанности протоколов IP и ICMP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что некоторые из пакетов могут исчезнуть из сети, не вызвав при этом никаких оповещений. В частности, протокол ICMP не предусматривает передачу сообщений о проблемах, возникающих при обработке IP-пакетов, несущих ICMP-сообщения об ошибках. Такое решение было принято разработчиками протокола, чтобы не порождать "штормы" в сетях, когда количество сообщений об ошибках лавинообразно возрастает.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Особенностью протокола ICMP является функциональное разнообразие решаемых задач, а следовательно, и связанных с этим сообщений. Все типы сообщений имеют один и тот же формат, однако интерпретация полей существенно зависит от того, к какому типу относится сообщение.</p>
<p align="center"><img src="img/chapter5/5.17.jpg"/></p>
<p align="center">Рисунок 5.17 – Формат ICMP-сообщения</p>
<ul>Заголовок ICMP-сообщения состоит из 8 байт:
<li>тип (1 байт) – числовой идентификатор типа сообщения,</li>
<li>код (1 байт) – числовой идентификатор, дифференцирующий тип ошибки,</li>
<li>контрольная сумма (2 байта) – подчитывается для всего ICMP-сообщения.</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Содержимое оставшихся четырех байтов в заголовке и поле данных зависит от значений полей типа и кода.</p>
<ul>На рисунке показана таблица основных ICMP-сообщений. Эти сообщения можно разделить на две группы:
<li>сообщения об ошибках,</li>
<li>сообщения запрос-ответ.</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сообщения типа запрос-ответ связаны в пары: эхо-запрос - эхо-ответ, запрос маски - ответ маски, запрос времени - ответ времени. Отравитель сообщения-запроса всегда рассчитывает на получение соответствующего сообщения-ответа.</p>
<p align="center"><img src="img/chapter5/5.18.jpg"/></p>
<p align="center">Рисунок 5.18 – Типы и коды ICMP-сообщений (дейтаграмма)</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сообщения, относящиеся к группе сообщений об ошибках, конкретизируются уточняющим кодом. На рисунке показан фрагмент таблицы кодов для сообщения об ошибке недостижимости узла назначения, имеющий тип 3. Из таблицы видно, что это сообщение может быть вызвано различными причинами, такими как неверный запрос сети или узла (код 0 или 1), отсутствием на конечном узле-адресате необходимого протокола прикладного уровня (код 2 – "протокол недостижим") или открытого порта UDP/TCP (код 3 –  "порт недостижим"). Узел (или сеть) назначения может быть также недостижим по причине временной неработоспособности аппаратуры или из-за того, что маршрутизатор не имеет данных о пути к сети назначения. Всего таблица содержит 15 кодов. Аналогичные таблицы кодов существуют и для других типов сообщений об ошибках.</p>
</font>
<p align="center">
		<a name="5.3.7.2"><font class="big">5.3.7.2 Протоколы маршрутизации RIP и OSPF</font></a>
</p>
<p align="center">
		<a name="5.3.7.2.1"><font class="big">5.3.7.2.1 Протокол RIP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол RIP (Routing Information Protocol – протокол маршрутной информации) является внутренним протоколом маршрутизации дистанционно-векторного типа.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Будучи простым в реализации, этот протокол  чаще всего используется в небольших сетях. Для IP имеются две версии RIP и RIPv1 и RIPv2.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как уже было отмечено ранее, протокол RIPv1 не поддерживает масок. Протокол RIPv2 передает информацию о масках сетей, поэтому он в большей степени соответствует требованиям сегодняшнего дня. Так как построение таблиц маршрутизации в обеих версиях протокола принципиально не отличается, для упрощения записей используется протокол версии 1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для измерения расстояния до сети стандарты протокола RIP допускают различные виды известных метрик: хопы (hop), значения пропускной способности, вносимые задержки, надежность сетей, а также любые комбинации этих метрик. Метрика должна обладать свойством аддитивности -  метрика составного пути должна быть равна сумме метрик составляющих этого пути. В большинстве реализаций RIP используется простейшая метрика – количество хопов (hop), то есть количество промежуточных маршрутизаторов, которые нужно преодолеть пакету до сети назначения.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее представлен процесс построения таблицы маршрутизации с помощью протокола RIP на примере составной сети, изображенной на рисунке 5.19.</p>
<p align="center"><img src="img/chapter5/5.19.jpg"/></p>
<p align="center">Рисунок 5.19 – Сеть, построенная на маршрутизаторах RIP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Процесс построения таблицы маршрутизации с помощью протокола RIP можно разделить на 5 этапов:</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) Создание минимальной таблицы. Данная составная сеть включает восемь IP-сетей, связанных четырьмя маршрутизаторами с идентификаторами: R1, R2, R3, и R4. Маршрутизаторы работающие по протоколу RIP, могут иметь идентификаторы, однако для протокола они не являются необходимыми. В RIP-сообщениях эти идентификаторы не передаются.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В исходном состоянии на каждом маршрутизаторе программы обеспечения стека TCP/IP автоматически создается минимальная таблица маршрутизации, в которой учитываются только непосредственно подсоединенные сети. Таблица 5.8 содержит вид минимальной таблицы маршрутизации маршрутизатора R1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.8 - Минимальная таблица  маршрутизации маршрутизатора R1</p>
<table align="center" border="1">
	<tr>
    	<td>Номер сети</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Порт</td>
        <td>Расстояние(hop)</td>
    </tr>
    <tr>
    	<td>201.36.14.0</td>
        <td>201.36.14.3</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.11.0.0</td>
        <td>132.11.0.7</td>
        <td>2</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>194.27.18.0</td>
        <td>194.27.18.1</td>
        <td>3</td>
        <td>1</td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Минимальные таблицы маршрутизации в других маршрутизаторах будут выглядеть соответственно, например, таблица маршрутизатора R2 будет состоять из трех записей (таблица 5.9)</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.9 - Минимальная таблица  маршрутизации маршрутизатора R2</p>
<table align="center" border="1">
	<tr>
    	<td>Номер сети</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Порт</td>
        <td>Расстояние(hop)</td>
    </tr>
    <tr>
    	<td>132.11.0.0</td>
        <td>132.11.0.101</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.17.0.0</td>
        <td>132.17.0.1</td>
        <td>2</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.15.0.0</td>
        <td>132.15.0.6</td>
        <td>3</td>
        <td>1</td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) Рассылка минимальной таблицы соседям. После инициализации каждый маршрутизатор начинает посылать своим соседям сообщения протокола RIP, в которых содержится его минимальная таблица. RIP-сообщения передаются в дейтаграммах протокола UDP и включают два параметра для каждой сети: ее IP-адрес и расстояние до нее от передающего сообщение маршрутизатора.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По отношению к любому маршрутизатору являются те маршрутизаторы, которым данный маршрутизатор может передать  IP-пакет по какой-либо своей сети, не пользуясь услугами промежуточных маршрутизаторов. Например, для маршрутизатора R1 соседями являются маршрутизаторы R2 и R3, а для маршрутизатора R4 – маршрутизаторы R2 и R3.</p>
<ul>Таким образом, маршрутизатор R1 передает маршрутизаторам R2 и R3 следующие сообщения:
<li>сеть 201.36.14.0, расстояние 1;</li>
<li>сеть 132.11.0.0, расстояние 1;</li>
<li>сеть, 194.27.18.0, расстояние 1.</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) Получение RIP-сообщений от соседей и обработка полученной информации. После получения аналогичных сообщений от маршрутизаторов R2 и R3 маршрутизатор R1наращивает каждое полученное поле метрики на единицу и запоминает, через какой порт и от какого маршрутизатора получена новая информация (адрес этого маршрутизатора станет адресом следующего маршрутизатора, если эта запись будет внесена в таблицу маршрутизации). Затем маршрутизатор начинает сравнивать новую информацию с той, которая хранится в его таблице маршрутизации (таблица 5.10)</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.10 – Таблица маршрутизации маршрутизатора R1</p>
<table align="center" border="1">
	<tr>
    	<td>Номер сети</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Порт</td>
        <td>Расстояние(hop)</td>
    </tr>
    <tr>
    	<td>201.36.14.0</td>
        <td>201.36.14.3</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.11.0.0</td>
        <td>132.11.0.7</td>
        <td>2</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>194.27.18.0</td>
        <td>194.27.18.1</td>
        <td>3</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.17.0.0</td>
        <td>132.11.0.101</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
    	<td>132.15.0.0</td>
        <td>132.11.0.101</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
    	<td>194.27.19.0</td>
        <td>194.27.18.51</td>
        <td>3</td>
        <td>2</td>
    </tr>
    <tr>
    	<td>202.101.15.0</td>
        <td>194.27.18.51</td>
        <td>3</td>
        <td>2</td>
    </tr>
    <tr>
    	<td><del>132.11.0.0</del></td>
        <td><del>132.11.0.101</del></td>
        <td><del>2</del></td>
        <td><del>2</del></td>
    </tr>
    <tr>
    	<td><del>194.27.18.0</del></td>
        <td><del>194.27.18.51</del></td>
        <td><del>3</del></td>
        <td><del>2</del></td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Записи с четвертой по девятую получены от соседних маршрутизаторов, и  они претендуют на помещение в таблицу. Однако только записи четвертой  по седьмую попадают в таблицу, а записи восьмая и девятая – нет. Это происходит потому, что они содержат данные об уже имеющихся в таблице маршрутизатора R1 сетях, а расстояние до них больше, чем в существующих записях.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол RIP замещает запись о какой-либо сети только в том случае, если новая информация имеет лучшую метрику (с меньшим расстоянием в хопах) чем имеющаяся. В результате в таблице маршрутизации о каждой сети остается только одна запись. Если же имеется несколько записей, равнозначных в отношении путей к одной и той же сети, то все равно в таблице остается одна запись, которая пришла в маршрутизатор первая по времени. Для этого правила существует исключение – если худшая информация о какой либо сети пришла от того же маршрутизатора, на основании сообщения которого была создана данная запись, то худшая информация замещает лучшую. Аналогичные операции с новой информацией выполняют и остальные маршрутизаторы сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4) Рассылка новой таблицы соседям. Каждый маршрутизатор отсылает новое RIP-сообщение всем своим соседям. В этом сообщении он помещает данные обо всех известных ему сетях: как непосредственно подключенных, так и удаленных, о которых маршрутизатор узнал из RIP-сообщений.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) Получение RIP-сообщений от соседей и обработка полученной информации. Этап 5 повторяет этап 3: маршрутизаторы принимают RIP-сообщения, обрабатывают содержащуюся в них информацию и на ее основе корректируют свои таблицы маршрутизации. В таблице 17.4 представлено, как это реализуется в маршрутизаторе R1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На этом этапе маршрутизатор R1 получает от маршрутизатора R3 информацию о сети 132.15.0.0, которую, тот в свою очередь, на предыдущем цикле работы получил от маршрутизатора R4. Маршрутизатор уже знает о сети 132.15.0.0, причем старая информация имеет лучшую метрику, чем новая, поэтому новая информация об этой сети отбрасывается.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.11 – Таблица маршрутизации маршрутизатора R1</p>
<table align="center" border="1">
	<tr>
    	<td>Номер сети</td>
        <td>Адрес следующего маршрутизатора</td>
        <td>Порт</td>
        <td>Расстояние(hop)</td>
    </tr>
    <tr>
    	<td>201.36.14.0</td>
        <td>201.36.14.3</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.11.0.0</td>
        <td>132.11.0.7</td>
        <td>2</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>194.27.18.0</td>
        <td>194.27.18.1</td>
        <td>3</td>
        <td>1</td>
    </tr>
    <tr>
    	<td>132.17.0.0</td>
        <td>132.11.0.101</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
    	<td>132.15.0.0</td>
        <td>132.11.0.101</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
    	<td><del>132.15.0.0</del></td>
        <td><del>194.27.18.51</del></td>
        <td><del>3</del></td>
        <td><del>3</del></td>
    </tr>
    <tr>
    	<td>194.27.19.0</td>
        <td>194.27.18.51</td>
        <td>3</td>
        <td>2</td>
    </tr>
    <tr>
    	<td><del>194.27.19.0</del></td>
        <td><del>132.11.0.101</del></td>
        <td><del>2</del></td>
        <td><del>3</del></td>
    </tr>
    <tr>
    	<td><del>202.101.15.0</del></td>
        <td><del>194.27.18.51</del></td>
        <td><del>3</del></td>
        <td><del>2</del></td>
    </tr>
    <tr>
    	<td>202.101.16.0</td>
        <td>132.11.0.101</td>
        <td>2</td>
        <td>3</td>
    </tr>
    <tr>
    	<td><del>202.101.16.0</del></td>
        <td><del>194.27.18.51</del></td>
        <td><del>3</del></td>
        <td><del>3</del></td>
    </tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;О сети 202.101.16.0 маршрутизатор R1 узнает на этом этапе впервые, причем данные о ней приходят от двух соседей – от R3 и R4. Поскольку метрики в этих сообщениях указаны одинаковые, то в таблицу попадают данные, пришедшие первыми. В нашем примере считается, что маршрутизатор R2 определил маршрутизатор R3 и первым переслал свое RIP-сообщение маршрутизатору R1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если маршрутизаторы периодически повторяют этапы рассылки и обработки RIP-сообщений, то за конечное время в сети установится корректный режим маршрутизации. Под корректным режимом маршрутизации здесь понимается такое состояние таблиц маршрутизации, когда все сети достижимы из любой сети с помощью некоторого рационального маршрута. Пакеты будут доходить до адресатов и не будут зацикливаться в петлях, подобных той, которая образуется на рисунке 5.20 маршрутизаторами R1, R2, R3 и R4.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Очевидно, если в сети все маршрутизаторы, их интерфейсы и соединяющие их линии связи остаются работоспособными, то объявления  по протоколу RIP можно делать, достаточно редко, например один раз в день. Однако в сетях постоянно происходят изменения – меняется работоспособность маршрутизаторов и линий связи, кроме того, маршрутизаторы и линии связи могут добавляться в существующую сеть или же выводиться из ее состава.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для адаптации к изменениям в сети протокола RIP использует ряд механизмов.</p>
</font>
<p align="center">
		<a name="5.3.7.2.2"><font class="big">5.3.7.2.2 Адаптация маршрутизаторов RIP к изменениям состояния сети</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;К новым маршрутам маршрутизаторы RIP приспосабливаются просто – они передают новую информацию в очередном сообщении своим соседям м постепенно эта информация становится известна всем маршрутизаторам сети. А вот к изменениям, связанным с потерей какого-либо маршрута, маршрутизаторы RIP адаптируются сложнее. Это связано с тем, что в формате сообщений протокола RIP нет поля, которое бы указывало на то, что к данной сети больше не существует.</p>
<ul>Для уведомления о том, что некоторый маршрут недействителен, используются два механизма:
<li>истечение времени жизни маршрута;</li>
<li>указание специального (бесконечного) расстояния до сети, ставшей недоступной.</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Механизм истечения времени жизни маршрута основан на том, что каждая запись таблицы  маршрутизации (как и записи таблицы продвижения моста/коммутатора), полученная по протоколу RIR имеет время жизни (TTL). При поступлении очередного RIP-сообщения, которое подтверждает справедливость данной записи, таймер времени жизни устанавливается в исходное состояние, а затем из него каждую секунду вычитается единица. Если за время тайм-аута не придет новое сообщение об этом маршруте, он помечается как недействительный.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Время тайм-аута связано с периодом рассылки векторов по сети. В протоколе RIP период рассылки выбран равным 30 секундам, а в качестве тайм-аута выбрано шестикратное значение периода рассылки, то есть 180 секунд. Шестикратный запас времени нужен для уверенности в том, что сеть действительно стала недоступной, а не просто произошли потери RIP-сообщений (а это возможно, так как протокол RIP использует транспортный протокол UDP, который не обеспечивает надежной доставки сообщений). Если какой-либо маршрутизатор отказывает, переставая слать своим соседям сообщения о сетях, которые можно достичь через него, то через 180 секунд все записи, порожденные этим маршрутизатором, у его ближайших соседей станут недействительными. После этого процесс повторится уже для ближайших соседей - они вычеркнут подобные записи уже через 360 секунд.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно, сведения о сетях, пути к которым не могут теперь проходить через отказавший маршрутизатор, распространяются по сети не очень быстро. В этом заключается одна из причин выбора в качестве периода рассылки небольшой величины в 30 секунд. Механизм тайм-аута работает в тех случаях, когда маршрутизатор не может послать соседям сообщение об отказавшем маршруте, так как либо он сам неработоспособен, либо неработоспобна линия связи, по которой можно было бы передать сообщение.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда же сообщение послать можно, маршрутизаторы RIP используют прием, заключающийся в указании бесконечного расстояния до сети, ставшей недоступной. В протоколе RIP бесконечным условно считается расстояние в 16 хопов. Получив сообщение, в котором расстояние до некоторой сети равно 16 (или 15, что приводит к тому же результату, так как маршрутизатор наращивает полученное значение на 1), маршрутизатор должен проверить, исходит ли эта "плохая" информация о сети от того же маршрутизатора, сообщение которое послужило в свое время основанием для записи о данной сети в таблице маршрутизации. Если это тот же маршрутизатор, то информация считается достоверной и маршрутизатор помечается как недоступный.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Причиной выбора в качестве "бесконечного" расстояния столь небольшого числа является то, что в некоторых случаях отказы связей в сети вызывают длительные периоды некорректной работы маршрутизаторов RIP, выражающейся в зацикливании пакетов в петлях сети. И чем меньше расстояние, используемое в качестве "бесконечного", тем периоды короче.</p>
</font>
<p align="center">
		<a name="5.3.7.2.3"><font class="big">5.3.7.2.3 Пример зацикливания пакетов</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее рассмотрен случай зацикливания пакетов на примере сети, изображенной на рисунке 5.20. Пусть маршрутизатор R1 обнаружил, что его связь с непосредственно подключенной сетью 201.36.14.0 потеряна (например, по причине отказа интерфейса 201.36.14.3). Маршрутизатор R1 отмечает в своей таблице маршрутизации, что сеть 201.36.14.0 недоступна. В худшем случае он обнаружит это сразу же после отправки очередных RIP-сообщений так что до начала нового цикла его объявлений, в котором он должен сообщить соседям что расстояние до сети 201.36.14.0 стало равным 16, остается почти 30 секунд. Каждый маршрутизатор работает на основании своего внутреннего таймера, синхронизовав работу по рассылки объявлений с другими маршрутизаторами. Поэтому весьма вероятно, что маршрутизатор R2 опередит маршрутизатор R1 и передаст ему свое сообщение раньше, чем R1 успеет передать новость о недостижимости сети 201.36.14.0. А в этом сообщении имеются данные, порожденные записью в таблице маршрутизации R2 (таблица 5.12).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.12 - Таблица маршрутизации маршрутизатора R2</p>
<table align="center" border="1">
	<tr>
		<td>Номер сети</td>
		<td>Адрес следующего маршрутизатора</td>
		<td>Порт</td>
		<td>Расстояние</td>
	</tr>
    <tr>
		<td>201.36.14.0</td>
		<td>132.1.0.7</td>
		<td>1</td>
		<td>2</td>
	</tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Эта запись, полученная от маршрутизатора R1, была корректна до отказа интерфейса  201.36.14.3; теперь она устарела, но маршрутизатор R2 об этом не знает.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее маршрутизатор R1 получает новую информацию о сети 201.36.14.0 - эта сеть достижима через маршрутизатор R2 с метрикой 2. Раньше R1 также получал эту информацию от R2, но игнорировал ее, так как его собственная метрика для 201.36.14.0 была лучше. Теперь R1 должен принять данные о сети 201.36.14.0, полученные от R2, и заменить значение в таблице маршрутизации о недостижимости этой сети (таблица 5.13).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.13 - Таблица маршрутизации маршрутизатора R1</p>
<table align="center" border="1">
	<tr>
		<td>Номер сети</td>
		<td>Адрес следующего маршрутизатора</td>
		<td>Порт</td>
		<td>Расстояние</td>
	</tr>
    <tr>
		<td>201.36.14.0</td>
		<td>132.1.0.101</td>
		<td>2</td>
		<td>3</td>
	</tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В результате в сети образуется маршрутная петля: пакеты, направляемые узлам сети 201.36.14.0, станут передаваться маршрутизатором R2 маршрутизатору R1, а маршрутизатор R1 будет возвращать их маршрутизатору R2. IP-пакеты продолжат циркулировать по этой петле до тех пор, пока не истечет время жизни каждого пакета. Далее рассмотрены периоды времени, кратные времени жизни записей в таблицах маршрутизаторов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	Время 0-180 с. После отказа интерфейса в маршрутизаторах R1 и R2 будут сохранять не корректные записи. Маршрутизатор R2 по-прежнему снабжает маршрутизатор R1 своей записью о сети 201.36.14.0 с метрикой 2, так как ее время жизни не истекло пакеты зацикливаются.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	Время 180-360 с. В начале этого периода у маршрутизатора R2 истекает время жизни записи о сети 201.36.14.0 с метрикой 2, так как маршрутизатор R1 в предыдущий период посылал ему сообщения о сети 201.36.14.0 с худшей метрикой, чем у R2, и они не могли подтверждать эту запись. Теперь маршрутизатор R2 принимает от маршрутизатора R1 запись о сети 201.36.14.0 с метрикой 3 и трансформирует ее в запись метрикой 4. Маршрутизатор R1 не получает новых сообщений от маршрутизатора R2 о сети 201.36.14.0 с метрикой 2, поэтому время жизни его записи начинает уменьшаться. Пакеты продолжают зацикливаться.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-	Время 360-540 с. У маршрутизатора R1 истекает время жизни записи о сети 201.36.14.0 с метрикой 3. Маршрутизаторы R1 и R2 опять меняются ролями - R2 снабжает R1 устаревшей информацией о пути к сети 201.36.14.0, уже с метрикой 4, которую R1 преобразует в метрику 5. Пакеты продолжают зацикливаться.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если бы в протоколе RIP не было выбрано расстояние 16 в качестве недостижимого, то описанный процесс длился бы бесконечно (вернее, пока не была бы исчерпана разрядная сетка поля расстояния, и при очередном наращивании расстояния было бы зафиксировано переполнение).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В результате маршрутизатор R2 на очередном этапе описанного процесса получает от маршрутизатора R1 метрику 15, которая после наращивания, превращаясь в метрику 16, фиксирует недостижимость сети. Таким образом, в нашем примере период нестабильной боты сети длился 36 минут.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ограничение в 15 хопов сужает область применения протокола RIP до сетей, в которых число промежуточных маршрутизаторов не может быть больше 15. Для более масштабных сетей нужно применять другие протоколы маршрутизации, например OSPF, или разбивать сеть на автономные области.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Приведенный пример хорошо иллюстрирует главную причину нестабильности маршрутизаторов, работающих по протоколу RIP. Эта причина коренится в самом принципе работы дистанционно-векторных протоколов - использовании информации, полученной из "вторых рук". Действительно, маршрутизатор R2 передает маршрутизатору R1 информацию достижимости сети 201.36.14.0, за достоверность которой он сам не отвечает.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что при любых отказах интерфейсов и маршрутизаторов в сетях возникают маршрутные петли. Если бы маршрутизатор R1 успел передать сообщение о недостижимости сети 201.36.14.0 раньше ложной информации маршрутизатора R2, то маршрутная петля не образовалась бы. Так что маршрутные петли даже без дополнительных методов борьбы с ними возникают в среднем не более чем в половине потенциально возможных случаев.</p>
</font>
<p align="center">
		<a name="5.3.7.2.4"><font class="big">5.3.7.2.4 Протокол OSPF</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол OSPF (Open Shortest Path First – выбор кратчайшего пути первым) является последним (он принят в 1991 году) протоколом, основанном на алгоритме состояния связей, и обладает многими особенностями, ориентированными на применение в больших гетерогенных сетях.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол OSPF разбивает процедуру построения таблицы маршрутизации на два этапа. К первому этапу относится построение и поддержание базы данных о состоянии связей сети, ко второму – нахождение оптимальных маршрутов и генерация таблицы маршрутизации. Далее представлено последовательное описание этих этапов:</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) Построение  и поддержание базы данных о состоянии связей сети. Сети могут быть представлены в виде графа, в котором вершинами графа являются маршрутизаторы и подсети, а ребрами – связи между ними (рисунок 5.20). Каждый маршрутизатор обменивается  со своими соседями той информацией  о графе сети, которой он располагает к данному моменту. Этот процесс похож на процесс распространения векторов расстояний до сетей в протоколе RIP, однако сама информация качественно иная – это информация о топологии сети. Сообщения, с помощью которых распространяется топологическая информация, называются объявлениями о состоянии связей (Link State Advertisement, LSA) сети. При транзитной передаче объявлений LSA маршрутизаторы не модифицируют в RIP, а передают ее в неизменном виде. В результате все маршрутизаторы сети сохраняют в своей памяти идентичные сведения о текущей конфигурации графа связей сети.</p>
<p align="center"><img src="img/chapter5/5.20.jpg"/></p>
<p align="center">Рисунок 5.20 – Граф сети, построенный протоколом OSPF</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как известно, протокол OSPF  относится к протоколам маршрутизации, реализующим алгоритм состояния связей. Соответственно, для контроля состояния связей и соседних маршрутизаторов OSPF-маршрутизаторы передают друг другу особые сообщения HELLO каждые 10 секунд. Небольшой объем этих сообщений делает возможным частое тестирование состояния соседей и связей с ними. В том случае, когда сообщения HELLO перестают поступать от какого-либо непосредственного соседа, маршрутизатор делает вывод о том, что состояние связи изменилось с работоспособного на неработоспособное и вносит соответствующие коррективы в свою топологическую базу данных. Одновременно он отсылает всем непосредственным соседям обновление LSA об этом изменении, те также вносят исправления в свои базы данных и, в свою очередь, рассылают данное объявление LSA своим непосредственным соседям.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) Нахождение оптимальных маршрутов и генерация таблицы маршрутизации. Задача нахождения оптимального пути на графе является достаточно сложной и трудоемкой. В протоколе OSPF для ее решения используется интерактивный алгоритм Дейкстры.  Каждый маршрутизатор сети, действуя в соответствии с этим алгоритмом, ищет оптимальные маршруты от своих интерфейсов до всех известных ему подсетей. В каждом найденном таким образом маршруте запоминается только один шаг – до следующего маршрутизатора.  Данные об этом шаге и попадают в таблицу маршрутизации.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если состояние связей в сети изменилось, и произошла корректировка графа сети,  каждый маршрутизатор  заново ищет оптимальные маршруты и корректирует свою таблицу маршрутизации. Аналогичный процесс происходит и в том случае, когда в сети появляется новая связь или новый сосед, объявляющий о себе с помощью своих сообщений HELLO. При работе протокола OSPF конвергенция таблиц маршрутизации к новому согласованному состоянию происходит достаточно быстро, быстрее, чем в сетях, в которых работают дистанционно-векторные протоколы. Это время состоит из времени распространения по сети объявления LSA и времени работы алгоритма Дейкстры, который обладает быстрой сходимостью. Однако вычислительная сложность этого алгоритма предъявляет высокие требования к мощности процессора маршрутизатора.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда состояние сети не меняется, то объявление о связях не генерируется, топологические базы данных и таблицы маршрутизации не корректируются, что экономит пропускную способность сети и вычислительные ресурсы маршрутизаторов.  Однако у этого правила есть исключение: каждые 30 минут OSPF-маршрутизаторы обмениваются всеми записями базы данных топологической информации, то есть, синхронизируют их для более надежной работы сети. Так как этот период достаточно большой, то данное исключение незначительно сказывается на загрузке сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При поиске оптимальных маршрутов протокол OSPF по умолчанию использует метрику, учитывающую пропускную способность каналов связи. Кроме того, допускается применение двух других метрик, учитывающих задержки и надежность передачи пакетов каналами связи. Для каждой из метрик протокол OSPF строит отдельную таблицу маршрутизации. Выбор нужной таблицы происходит в зависимости от значений битов TOS (Type of Service) в заголовке пришедшего IP-пакета. Если в пакет бит D (Delay - задержка) установлен в 1, то для этого пакета маршрут должен выбираться из таблицы, в которой содержатся маршруты, минимизирующие задержку. Аналогично, пакет с установленным битом Т (Throughput -  пропускная способность) должен маршрутизироваться по таблице, построенной с учетом пропускной способности каналов, а установленный в единицу бит R (Reliability - надежность) указывает на то, что должна использоваться таблица для построения которой критерием оптимизации служит надежность доставки.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол OSPF поддерживает стандартные для многих протоколов значения расстояний для метрики, отражающей пропускную способность так, для сети Ethernet  она равна 10, для Fast Ethernet – 1, для канала Т-1 (Т1 – цифровой канал технологии PDH), обладающего пропускной способностью 1,544 Мбит/с, - 65, для канала с пропускной способностью 56Кбит/с – 1785. При наличии высокоскоростных каналов, таких как Gigabit Ethernet или STM-16/64, администратору  нужно задать другую шкалу скоростей, назначив единичное расстояние  наиболее скоростному каналу.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выборе оптимального пути на графе с каждым ребром графа связывается метрика, которая добавляется к пути, если данное ребро в него входит. Пусть в приведенном на рисунке 5.21 примере маршрутизатор R5 связаны с маршрутизаторами R6 и R7 каналами Т-1, а маршрутизаторы R6 и R7 связаны между собой каналом 56 Кбит/с. Тогда R7  определит оптимальный маршрут до сети 201.106.14.0 как составной, проходящий сначала через R5, а потом через R6, поскольку у этого маршрута метрика будет равна 65+65=130 единиц. Непосредственный маршрут через R6  не будет оптимальным, так как его метрика равна 1785.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол OSPF разрешает хранить в таблице маршрутизации несколько маршрутов к одной сети, если они обладают равными метриками. В таких случаях маршрутизатор может работать в режиме баланса загрузки маршрутов, отправляя  пакеты попеременно по каждому из маршрутов.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;К сожалению, вычислительная сложность протокола OSPF быстро растет с увеличением размера сети. Для преодоления этого недостатка  в протоколе OSPF вводится понятие области сети. Маршрутизаторы, принадлежащие некоторой области, строят граф связей только для этой области, что упрощает задачу. Между областями информация о связях не передается, а пограничные для областей маршрутизаторы обмениваются только информацией об адресах сетей, имеющихся в каждой из областей, и расстоянием от пограничного маршрутизатора до каждой сети. При передаче пакетов межу  областями выбирается один из пограничных маршрутизаторов области, а именно тот, у которого расстояние до нужной сети меньше.</p>
</font>
<p align="center">
		<a name="5.3.7.2.4"><font class="big">5.3.7.2.5 Взаимодействие протоколов маршрутизации</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В одной и той же сети могут одновременной работать несколько разных протоколов маршрутизации (рисунок 5.21). Это означает, что на некоторых (необязательно всех) маршрутизаторах сети установлено и функционирует несколько протоколов маршрутизации, но при этом, естественно,  через сеть взаимодействуют только одноименные протоколы. То есть если маршрутизатор 1 поддерживает, например, протоколы RIP и OSPF, маршрутизатор 2 – только RIP, а маршрутизатор 3 – только OSPF, а маршрутизаторы 2 и 3 вообще непосредственно друг с другом взаимодействовать не смогут.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В маршрутизаторе, который поддерживает одновременно несколько протоколов, каждая запись в таблице является  результатом работы одного из этих протоколов. Если информация о некоторой сети появляется от нескольких протоколов, то для однозначности выбора маршрута (а данные разных протоколов могут вести к разным рациональным маршрутам) устанавливаются приоритеты протоколов маршрутизации. Обычно предпочтение отдается протоколам LSA, как располагающим более полной информацией о сети по сравнению с протоколами DVA. В некоторых ОС в формах  вывода на экран и печать в каждой записи таблицы маршрутизации имеется отметка о том, с помощью какого протокола маршрутизации эта запись получена. Но даже если эта отметка на экран  и не выводится, она обязательно имеется во внутреннем представлении таблиц маршрутизации.</p>
<p align="center"><img src="img/chapter5/5.21.jpg"/></p>
<p align="center">Рисунок 5.21 – Применение нескольких протоколов маршрутизации в одной сети</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;По умолчанию каждый протокол маршрутизации, работающий на определенном маршрутизаторе, распространяет только "собственную" информацию, то есть информацию, которая была получена данным маршрутизатором по данному протоколу. Например, если о маршруте к некоторой сети маршрутизатор узнал по протоколу RIP, то и распространять по сети объявления об этом маршруте но будет с помощью протокола RIP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Однако такой "избирательный" режим работы маршрутизаторов ставит невидимые барьеры на пути распространения маршрутной информации, создавая в составной сети области взаимной недостижимости. Задача маршрутизации решалась бы эффективно, если бы маршрутизаторы могли обмениваться маршрутной информацией, полученной разными протоколами маршрутизации. Такая возможность реализуется в особом режиме работы  маршрутизатора, называемом перераспределением. Этот режим позволяет одному протоколу маршрутизации использовать не только "свои", но и "чужие" записи таблиц маршрутизации, полученные с помощью другого протокола маршрутизации, указанного при конфигурировании.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно, применение нескольких протоколов маршрутизации даже в пределах небольшой составной сети – дело не простое, от администратора требуется провести определенную работу по конфигурированию каждого маршрутизатора. Очевидно, что для крупных составных сетей нужно качественно иное решение.</p>
</font>
<p align="center">
		<a name="5.3.8"><font class="big">5.3.8 Отображение IP-адресов на локальные адреса</font></a>
</p>
<p align="center">
		<a name="5.3.8.1"><font class="big">5.3.8.1 Протокол ARP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Одной из главных задач, которая ставилась при создании протокола IP, являлось обеспечение совместной согласованной работы в сети, состоящей из подсетей, в общем случае использующих разные сетевые технологии. Взаимодействие технологий TCP/IP с локальными технологиями  подсетей происходит многократно при  перемещении IP-пакета по составной сети. На каждом маршрутизаторе протокол IP определяет, какому следующему маршрутизатору в этой сети надо направить пакет. В результате решения этой задачи протоколу IP становится известен IP-адрес интерфейса следующего маршрутизатора (или конечного узла, если эта сеть является сетью назначения). Чтобы локальная технология сети смогла доставить пакет  на следующий маршрутизатор, необходимо:
<ul>
<li>упаковать пакет в кадр соответствующего для данной сети формата (например, Ethernet);</li>
<li>снабдить данный кадр локальным адресом следующего маршрутизатора.</li>
</ul></p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Решением этих задач, занимается уровень сетевых интерфейсов стека TCP/IP. </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как уже было сказано, никакой функциональной зависимости между локальным адресом (MAC-адресом) и его IP-адресом не существует, следовательно, единственный способ установления соответствия – это ведение таблиц. В результате  конфигурирования сети  каждый интерфейс "знает" свой IP-адрес и локальный адрес, что можно рассматривать как таблицу, состоящую из одной строки. Проблема состоит в том, как организовать обмен имеющейся информацией между всеми узлами сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для определения локального адреса (MAC-адреса) по IP-адресу  используется протокол разрешения адресов (Address Resolution Protocol, ARP). Протокол разрешения адресов реализуется различным образом в зависимости от того, работает ли в данной сети протокол локальной сети (Ethernet, Token Ring, FDDI) с возможностью широковещания или же какой либо из протоколов сети (Frame Relay, ATM), которые, как правило, не поддерживают широковещательный доступ.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.22 представлена работа  протокола ARP в локальных сетях с широковещанием. На рисунке показан фрагмент IP-сети, включающий две сети – Ethernet1 (из трех конечных узлов A, B и C) и Ethernet2 (из двух конечных узлов D и E). Сети подключены соответственно к интерфейсам 1 и 2 маршрутизатора. Каждый сетевой интерфейс имеет IP-адрес и MAC-адрес. Пусть  в какой-то момент IP-модуль узла C направляет пакет узлу D. Протокол IP узла C определил IP-адрес интерфейса следующего маршрутизатора – это IP1. Теперь, прежде чем упаковать пакет   в кадр Ethernet и направить его маршрутизатору, необходимо определить соответствующий MAC-адрес. Для решения этой задачи протокол IP обращается к протоколу ARP. Протокол ARP поддерживает на каждом интерфейсе сетевого адаптера или маршрутизатора отдельную ARP-таблицу, в которой в ходе функционирования сети накапливается информация о соответствии между IP-адресами и  MAC-адресами других интерфейсов данной сети. Первоначально, при включении компьютера или маршрутизатора в сеть все его ARP-таблицы пусты.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) На первом шаге происходит передача от протокола IP протоколу ARP сообщения "Определить, какой MAC-адрес имеет интерфейс с адресом IP<sub>1</sub>".</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) Работа протокола ARP начинается с просмотра собственной ARP- таблицы. Предположим, что среди содержащихся в ней записей отсутствует запрашиваемый IP-адрес.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) В этом случае исходящий IP-пакет, для которого оказалось невозможным определить локальный адрес из ARP-таблицы, запоминается в буфере, а протокол ARP формирует ARP-запрос, вкладывает его в кадр протокола Ethernet и широковещательно рассылает.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4) Все интерфейсы сети Ethernet1 получают ARP-запрос и направляют его "своему" протоколу ARP. ARP сравнивает указанный в запросе адрес IP<sub>1</sub> c IP-адресом интерфейса, на который поступил этот запрос. Протокол ARP, который констатировал совпадение (в данном случае это ARP маршрутизатора 1), формирует ARP-ответ.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) В ARP-ответе маршрутизатор указывает локальный адрес MAC1 своего интерфейса и отправляет его запрашивающему узлу (в данном примере узлу C), используя его локальный адрес. Широковещательный ответ в этом случае не требуется, так как формат ARP-запрос предусматривает поля локального и сетевого адресов отправителя. Зона распространения ARP-запросов ограничивается сетью Ethernet1, так как на пути широковещательных кадров барьером стоит маршрутизатор.</p>
<p align="center"><img src="img/chapter5/5.22.jpg"/></p>
<p align="center">Рисунок 5.22 – Схема работы протокола ARP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.23 показан кадр Ethernet с вложенным в него ARP-сообщением. ARP-запросы и ARP-ответы имеют один и тот же формат.</p>
<p align="center"><img src="img/chapter5/5.23.jpg"/></p>
<p align="center">Рисунок 5.23 – Инкапсуляция ARP-сообщений в Ethernet</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В таблице 5.12 в качестве примера приведены значения полей реального ARP-запроса, переданного по сети Ethernet .</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.12 – Пример ARP-запроса</p>
<table align="center" border="1">
	<tr>
		<td>Поле</td>
		<td>Значение</td>
	</tr>
    <tr>
		<td>Тип сети</td>
		<td>1 (0х1)</td>
	</tr>
    <tr>
		<td>Тип протокола</td>
		<td>2048 (0х800)</td>
	</tr>
    <tr>
		<td>Длина локального адреса</td>
		<td>6 (0х6)</td>
	</tr>
    <tr>
		<td>Длина сетевого адреса</td>
		<td>4 (0х4)</td>
	</tr>
    <tr>
		<td>Операция</td>
		<td>1 (0х1)</td>
	</tr>
    <tr>
		<td>Локальный адрес отправителя</td>
		<td>008048ЕВ7Е60</td>
	</tr>
    <tr>
		<td>Сетевой адрес отправителя</td>
		<td>194.85.135.75</td>
	</tr>
    <tr>
		<td>Локальный (искомый) адрес получателя</td>
		<td>000000000000</td>
	</tr>
    <tr>
		<td>Сетевой адрес получателя</td>
		<td>194.85.135.65</td>
	</tr>
</table>    
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В поле типа сети для сетей Ethernet указывается значение 1. Поле типа протокола позволяет использовать протокол ARP не только с протоколом IP, но и с другими сетевыми протоколами. Для IP значение этого поля равно 0х800. Длина локального адреса для протокола Ethernet равна 6 байт, а длина IP-адреса – 4байта. В поле операции для ARP-запросов указывается значение 1, для ARP-ответов – значение 2.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Из этого запроса видно, что в сети Ethernet узел с IP-адресом 194.85.135.75 пытается определить, какой MAC-адрес имеет другой узел той же сети, сетевой адрес которого 194.85.135.65. Поле искомого адреса заполнено нулями.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ответ присылает узел, опознавший свой IP-адрес. Если в сети нет машины с искомым IP-адресом, то ARP-ответа не будет. Протокол IP уничтожает IP-пакеты, направляемые по этому адресу. В таблице 5.13 приведен пример ARP-ответа, который поступил на приведенный в таблице 5.12 ARP-запрос.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.13 – Пример ARP-ответа</p>
<table align="center" border="1">
	<tr>
		<td>Поле</td>
		<td>Значение</td>
	</tr>
    <tr>
		<td>Тип сети</td>
		<td>1 (0х1)</td>
	</tr>
    <tr>
		<td>Тип протокола</td>
		<td>2048 (0х800)</td>
	</tr>
    <tr>
		<td>Длина локального адреса</td>
		<td>6 (0х6)</td>
	</tr>
    <tr>
		<td>Длина сетевого адреса</td>
		<td>4 (0х4)</td>
	</tr>
    <tr>
		<td>Операция</td>
		<td>1 (0х1)</td>
	</tr>
    <tr>
		<td>Локальный (искомый) адрес отправителя</td>
		<td>00E0F77F1920</td>
	</tr>
    <tr>
		<td>Сетевой адрес отправителя</td>
		<td>194.85.135.65</td>
	</tr>
    <tr>
		<td>Локальный адрес получателя</td>
		<td>008048ЕВ7Е60</td>
	</tr>
    <tr>
		<td>Сетевой адрес получателя</td>
		<td>194.85.135.75</td>
	</tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В результате обмена ARP-сообщениями модуль IP, пославший запрос с интерфейса, имеющего адрес 194.85.135.75, определил, что IP-адресу 194.85.135.65 соответствует MAC-адрес 00E0F77F1920. Этот адрес затем помещается в заголовок кадра Ethernet,  ожидавшего отправления IP-пакета.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы уменьшить число ARP-обращений в сети, найденное соответствие между IP- адресом и MAC-адресом сохраняется в ARP-таблице соответствующего  интерфейса, в данном случае это – запись:</p>
<p style="text-align:center">194.85.135.65 - 00E0F77F1920</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Данная запись в ARP-таблице появляется автоматически, спустя несколько миллисекунд после того, как модуль ARP проанализирует ARP-ответ. Теперь, если вдруг вновь возникает необходимость послать пакет по адресу 194.85.135.65, то протокол IP прежде, чем посылать широковещательный запрос, проверит,  нет ли уже такого адреса в ARP-таблице.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ARP-таблица пополняется не только за счет поступающих на данный интерфейс ARP-ответов, но и в результате извлечения полезной информации из широковещательных ARP-запросов.  Действительно, в каждом запросе, как это видно из таблиц 15.2 и 15.3, содержатся IP-адрес и MAC-адрес отправителя. Все интерфейсы, получившие этот запрос, могут поместить информацию о соответствии локального и сетевого адресов отправителя в собственную ARP-таблицу. В частности, все узлы получившие ARP-запрос (таблица 15.2), могут выполнить свою ARP-таблицу записью:</p>
<p style="text-align:center">194.85.135.75 – 008048EB7E60</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таким образом, вид ARP-таблицы, в которую, в ходе работы сети были добавлены две упомянутые записи, иллюстрирует таблица 5.14.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таблица 5.14 – Пример ARP-таблицы</p>
<table align="center" border="1">
	<tr>
		<td>IP-адрес</td>
		<td>MAC-адрес</td>
		<td>Тип записи</td>
	</tr>
    <tr>
		<td>194.85.135.65</td>
		<td>00E0F77F1920</td>
		<td>Динамический</td>
	</tr>
    <tr>
		<td>194.85.135.75</td>
		<td>008048ЕВ7Е60</td>
		<td>Динамический</td>
	</tr>
    <tr>
		<td>194.85.60.21</td>
		<td>008048ЕВ7567</td>
		<td>Статический</td>
	</tr>
</table>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно из таблицы 5.4 в ARP-таблицах существует два типа записей: динамические и статические. Статические записи создаются вручную с помощью утилиты arp и не имеют срока устаревания, точнее, они существуют до тех пор, пока компьютер или маршрутизатор остается включены. Динамические записи должны периодически обновляться. Если запись не обновлялась в течение  определенного времени (порядка нескольких минут), то она исключается из таблицы. Таким образом, в ARP-таблице содержатся записи не обо всех узлах сети, а только о тех, которые активно участвуют в сетевых операциях. Поскольку такой способ хранения информации называют  кэшированием, ARP-таблицы иногда называют ARP-кэшем.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить, что некоторые реализации протоколов IP и ARP не ставят IP-пакеты в очередь на время ожидания ARP-ответов. Вместо этого IP-пакет просто уничтожается, а его восстановление возлагается на модуль TCP или прикладной процесс, работающий через  протокол UDP.  Такое восстановление выполняется за счет тайм-аутов и повторных передач. Повторная передача сообщения проходит успешно, так как первая попытка уже вызвала заполнение ARP-таблицы.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Совсем другой способ  разрешения адресов используется в глобальных сетях, в которых не поддерживается широковещательная рассылка.  Здесь администратору  сети чаще всего, приходится вручную формировать и помещать на какой либо сервер ARP-таблицы, в которых, он задает, например, соответствие IP-адресов адресами Х.25, имеющих для протокола IP смысл локальных адресов. В то же время сегодня наметилась тенденция автоматизации работы протокола ARP и в глобальных сетях.  Для этой цели среди всех маршрутизаторов, подключенных к какой-либо глобальной сети, выделяется специальный маршрутизатор, который ведет ARP-таблицу для всех остальных узлов и маршрутизаторов этой сети.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При таком централизованном подходе вручную нужно задать для всех узлов и маршрутизаторов только IP-адрес и локальный адрес выделенного, для этих целей маршрутизатора. При включении  каждый узел и маршрутизатор регистрирует свои адреса в выделенном  маршрутизаторе. Всякий раз, когда возникает необходимость определения IP-адреса локального адреса, модуль ARP обращается к выделенному маршрутизатору с запросом и автоматически получает ответ без участия администратора. Работающий таким образом маршрутизатор называют ARP-сервером.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В некоторых случаях возникает обратная задача нахождения IP-адреса по известному локальному адресу. Тогда в действие вступает реверсивный протокол разрешения адресов (Reverse Address Resolution Protocol, RARP). Этот протокол используется, например, при старте бездисковых станций, не знающих в начальный момент времени своего IP-адреса, но знающих MAC- адрес своего сетевого адаптера.</p>
</font>
<p align="center">
		<a name="5.3.8.2"><font class="big">5.3.8.2 Протокол Proxy-ARP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол Proxy-ARP – это одна из разновидностей протокола ARP, позволяющая отображать IP-адреса на аппаратные адреса (MAC-адреса) в сетях, поддерживающих широковещание, даже в тех случаях, когда искомый узел находится за пределами данного домена коллизий.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.24 показана сеть, один из конечных узлов которой (компьютер D) работает в режиме удаленного узла. Данный конечный узел обладает всеми возможностями компьютеров, работающих в основной части сети Ethernet, в частности он имеет IP-адрес (IP<sub>D</sub>), относящийся к тоже сети. Для всех конечных узлов сети Ethernet особенности подключения удаленного узла абсолютно прозрачны – они взаимодействуют с ним обычным образом. Чтобы такой режим взаимодействия стал возможным, среди прочего, необходим протокол Proxy-ARP. Поскольку удаленный узел подключен у сети по протоколу PPP, то он не имеет MAC-адреса.</p>
<p align="center"><img src="img/chapter5/5.24.jpg"/></p>
<p align="center">Рисунок 5.24 – Схема работы Proxy-ARP</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Пусть приложение, работающее, например, на компьютере С, решает послать пакет компьютеру D. Ему известен IP-адрес узла назначения (IP<sub>D</sub>), однако, для передачи пакета по сети Ethernet его необходимо упаковать в кадр Ethernet и снабдить MAC-адресом. Для определения MAC-адреса IP-протокол узла С обращается к протоколу ARP, который посылает широковещательное сообщение с ARP-запросом. Если бы в этой сети на маршрутизаторе не был установлен протокол Proxy-ARP, на этот запрос не откликнулся бы ни один узел.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Однако протокол Proxy-ARP установлен на маршрутизаторе и работает следующим образом. При подключении к сети удаленного узла D в таблицу ARP маршрутизатора заносится запись:</p>
<p style="text-align:center">IPD-MAC1-int2,</p>
<ul>которая означает, что:
<li>при поступлении ARP-запроса на маршрутизатор относительно адреса IP<sub>D</sub> в ARP-ответ будет помещен адрес MAC1, соответствующий аппаратному адресу интерфейса 1 маршрутизатора,</li>
<li>узел, имеющий адрес IP<sub>D</sub>, подключен к интерфейсу 2 маршрутизатора.</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В ответ, на посланный узлом С широковещательный ARP-запрос откликается маршрутизатор с установленным протоколом Proxy-ARP. Он посылает "ложный" ARP-ответ, в котором на место аппаратного адреса компьютера D помещает собственный адрес MAC1. Узел С, не подозревая "подвоха", посылает кадр с IP-пакетом по адресу MAC<sub>1</sub>. Получив кадр, маршрутизатор с установленным протоколом Proxy-ARP "понимает", что он направлен не ему (в пакете указан чужой IP-адрес) и, следовательно, надо искать адрес в ARP-таблице. Из таблицы видно, что кадр надо направить узлу, подключенному ко второму интерфейсу.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Таким образом, выше была рассмотрена простейшая схема применения протокола Proxy-ARP, которая, тем не менее, достаточно полно отражает логику его работы.</p>
</font>
<p align="center">
		<a name="5.4"><font class="big">5.4 Транспортный уровень стека TCP/IP. Протоколы транспортного уровня TCP и UDP</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Транспортный уровень выполняет посредническую роль между приложениями  и транспортной инфраструктурой сети. В то время как задачей уровня межсетевого взаимодействия, к которому относится протокол IP, является  передача данных между  сетевыми интерфейсами в составной сети, главная задача транспортного уровня, которую решают протоколы TCP и UDP, заключается в передаче данных между прикладными процессами, выполняющимися на  компьютерах в сети.</p>
<ul>К транспортному уровню стека TCP/IP относятся:
<li>протокол управления передачей (ТСР),</li>
<li>протокол пользовательских дейтаграмм (UDP).</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протоколы TCP и UDP, как и протоколы прикладного уровня, устанавливаются на конечных узлах.</p>
</font>
<p align="center">
		<a name="5.4.1"><font class="big">5.4.1 Мультиплексирование и демутильтиплексирование с помощью портов и сокетов</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждый компьютер может выполнять несколько процессов, более того, даже отдельный прикладной процесс может иметь несколько точек входа, выступающих в качестве адресов назначения для пакетов данных. Поэтому доставка данных на сетевой интерфейс компьютера – получателя – это еще не конец пути, так как данные необходимо переправить конкретному процессу – получателю. Процедура  распределения протоколами TCP и UDP поступающих от сетевого уровня пакетов между прикладными процессами называется <em>демультиплексированием</em> (рисунок 5.25)</p>
<p align="center"><img src="img/chapter5/5.25.jpg"/></p>
<p align="center">Рисунок 5.25 – Мультиплексирование и демультиплексирование на транспортном уровне</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Существует и обратная задача: данные, генерируемые разными приложениями, работающими на одном конечном узле, должны быть переданы общему для всех них протокольному модулю IP для последующей отправки в сеть. Эту работу, называемую <em>мультиплексированием</em>, тоже выполняют протоколы TCP и UDP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протоколы TCP и UDP ведут для каждого приложения две системные очереди: очередь данных, поступающих к приложению из сети, и очередь данных, отправляемых этим приложением в сеть. Такие системные очереди называются портами, причем входная и выходная очереди одного приложения рассматриваются как один порт. Для идентификации портов  им присваивают номера.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если процессы  представляют собой  популярные системные службы, такие как FTP, telnet, HTTP, TFTP, DNS, то за ними  закрепляются  стандартные назначенные номера, называемые также  хорошо известными номерами портов. Эти номера закрепляются и публикуются  в стандартах Интернета. Так, номер 21 закреплен за серверной частью службы удаленного доступа к файлам FTP, а 23 – за серверной частью службы удаленного управления telnet. Назначенные номера из диапазона от 0 до 1023 являются  уникальными в пределах Интернета и закрепляются за приложениями централизованно.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для тех приложений, которые еще не стали столь распространенными, номера портов назначаются локально разработчиками этих приложений или операционной системой  в ответ на поступление запроса от приложения.  На каждом компьютере  операционная система  ведет список занятых  и свободных  номеров портов. При поступлении запроса от приложения, выполняемого на одном компьютере, операционная система выделяет ему первый свободный номер. Такие номера  называют динамическими. В дальнейшем все сетевые  приложения должны адресоваться к данному  приложению с указанием назначенного ему  динамического номера порта.  После того как  приложение завершит работу, его номер возвращается в список свободных и может  быть  назначен другому приложению.  Динамические номера  являются уникальными в пределах  каждого компьютера, но при этом обычной является ситуация  совпадения номеров портов приложений, выполняемых на разных компьютерах.  Как правило,  клиентские части  известных приложений (DNS, WWW, FTP, telnet и др.) получают динамические номера портов от ОС.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Все, что было сказано о портах, в равной  степени относиться к обоим протоколам транспортного уровня (TCP и UDP). В принципе, нет никакой зависимости между назначением номеров портов для приложений, использующих протокол TCP, и приложений,  работающих с протоколом UDP. Приложения, которые передают данные на уровень IP по протоколу UDP, получают номера, называемые UDP – портами.  Аналогично, приложениям, обращающимся к протоколу TCP, выделяются TCP – порты.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В том и другом случае  это могут быть как назначенные, так и  динамические номера. Диапазоны  чисел,  из которых выделяются номера  TCP- и UDP- портов, совпадают от 0 до 1023, для назначенных, и от 1024 до 65535 для динамических. Однако никакой связи между  назначенными номерами TCP- и UDP-портов нет. Даже если номера TCP и UDP – портов совпадают, они идентифицируют  разные приложения. Например, одному  приложению может быть назначен TCP- порт 1750, а другому UDP – порт 1750.  В некоторых случаях, когда приложение может обращаться по выбору к протоколу TCP или UDP (например, таким приложением  является DNS), ему исходя из удобства запоминания, назначаются  совпадающие номера TCP и UDP – портов (в данном примере – это хорошо известный номер 53).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Стандартные назначения  номера портов  уникально идентифицируют тип приложения (FTP, или HTTP, или DNS и т. д.), однако они не могут  использоваться для однозначной идентификации прикладных процессов, связанных с каждым из этих типов приложений.  Пусть, например, на одном хосте запущены две копии DNS – сервера- DNS- сервер 1, DNS – сервер 2 (рисунок 5.26). Каждый из этих DNS – серверов имеет хорошо известный UDP – порт 53. Какому из этих серверов нужно было бы направить запрос клиента, если бы  в DNS – запросе  в качестве идентификатора сервера был указан только номером порта.</p>
<p align="center"><img src="img/chapter5/5.26.jpg"/></p>
<p align="center">Рисунок 5.26 – Демультиплексирование протокола UDP на основе сокетов</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Чтобы снять неоднозначность в идентификации приложений, разные копии связываются  с разными IP – адресами. Для этого сетевой интерфейс компьютера, на котором выполняется несколько копий приложения, должен иметь соответствующее число IP – адресов -  на рисунке это IP1 и IP2. Во всех IP – пакетах, направляемых  DNS серверу 1, в качестве IP – адреса указывается IP 1, а DNS - серверу 2 – адрес  IP2. Поэтому  показанный на рисунке  пакет, в поле данных которого содержится UDP – дейтаграмма с указанным номером порта 53, а в поле заголовка задан адрес IP2, будет направлен однозначно определенному адресату - DNS - серверу 2.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Прикладной процесс однозначно определяется в пределах сети и в пределах отдельного  компьютера парой (IP – адрес, номер порта), называемой сокетом. Сокет определенный IP – адресом и номером UDP – порта, называется UDP – сокетом, а IP – адресом и номером TCP – порта – TCP – сокетом.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить что, после получения IP – пакета от протокола канального уровня протокол IP  анализирует содержимое заголовка этого пакета, после чего заголовок отбрасывается, и "наверх" передается содержимое  поля данных IP – пакета, например UDP – дейтаграмма. Упрощение состоит  в том, что вместе с содержимым поля данных  на транспортный  уровень передается  извлеченный из заголовка IP – адрес назначения, который используется для однозначной идентификации приложения.</p>
</font>
<p align="center">
		<a name="5.4.2"><font class="big">5.4.2 Протокол TCP. Функции протокола TCP</font></a>
</p>
<p align="center">
		<a name="5.4.2.1"><font class="big">5.4.2.1 Разбиение на TCP-сегменты</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол TCP  предназначен для передачи данных между приложениями. Этот протокол основан на логическом соединении, что позволяет ему обеспечивать гарантированную доставку данных, используя в качестве инструмента ненадежный дейтаграммный сервис протокола IP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При работе на хосте – отправителе  протокол TCP рассматривает информацию, поступающую к нему от прикладных процессов, как неструктурированный поток байтов (рисунок 5.27).  Поступающие данные буферизируются средствами TCP. Для передачи на сетевой уровень из буфера "вырезается " некоторая непрерывная часть данных, которая называется  сегментом  и снабжается заголовком.</p>
<p align="center"><img src="img/chapter5/5.27.jpg"/></p>
<p align="center">Рисунок 5.27 – Форматирование TCP–сегментов из потока байтов</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Необходимо отметить что, в отличие от протокола UDP, который создает свои дейтаграммы на основе логически обособленных единиц данных – сообщений, генерируемых приложениями, протокол TCP делит поток данных на сегменты без учета их смысла или внутренней структуры.</p>
</font>
<p align="center">
		<a name="5.4.2.1.1"><font class="big">5.4.2.1.1 Формат заголовка TCP-сегмента</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP-сегмент состоит из заголовка и данных. Заголовок сегмента состоит из 32-разрядных слов и имеет переменную длину, зависящую от размера поля Options, но всегда кратную 32 битам. За заголовком непосредственно следуют данные - часть потока данных пользователя, передаваемая в данном сегменте. Формат заголовка представлен на рисунке 5.28.</p>
<p align="center"><img src="img/chapter5/5.28.jpg"/></p>
<p align="center">Рисунок 5.28 – Формат заголовка TCP-сегмента</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Значения полей заголовка следующие.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source Port – поле номера порта процесса источника, имеет длину 16 бит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destination Port – поле номера порта отправителя, имеет длину 16  бит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sequence Number - номер первого байта данных в сегменте для текущего соединения (если в сегменте пересылаются октеты с 2001-го по 3000-й, то SN=2001). Определяет смещение сегмента относительно потока отправляемых данных.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если в заголовке сегмента установлен бит SYN (фаза установления соединения), то в поле SN записывается начальный номер (ISN), например, 0. Номер первого байта данных, посылаемых после завершения фазы установления соединения, равен ISN+1.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acknowledgment Number - поле максимального номера байта в полученном сегменте, увеличенный на единицу, занимает 32 бита. Другими словами, если установлен бит ACK, то это поле содержит порядковый номер октета, который отправитель данного сегмента желает получить. Это означает, что все предыдущие октеты (с номерами от ISN+1 до ACK-1 включительно) были успешно получены.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hlen - длина TCP-заголовка в 32-битных словах занимает 4 бита.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reserved – поле резерва, заполняется нулями, поле занимает 6 бит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control Bits - управляющие биты занимают 6 бит, активным является положение "бит установлен". Положительное значение сигнализируется  установкой этих битов в единицу.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-URG – срочное сообщение, поле срочного указателя (Urgent Pointer) задействовано;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- ACK – квитанция на принятый сегмент, поле номера подтверждения (Acknowledgment Number) задействовано;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- PSH – запрос на отправку сообщения без ожидания заполнения буфера, осуществляется "проталкивание" - если модуль TCP получает сегмент с установленным флагом PSH, то он немедленно передает все данные из буфера приема процессу-получателю для обработки, даже если буфер не был заполнен;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- RST – запрос на восстановление соединения, то есть перезагрузка текущего соединения;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- SYN – запрос на установление соединения, сообщение, используемое для синхронизации счетчиков переданных данных при установлении соединения;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- FIN –  признак достижения передающей стороной последнего байта в потоке передаваемых данных - нет больше данных для передачи.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Window - размер окна в октетах, то есть количество байтов данных, ожидаемых отправителем данного сегмента, начиная с байта, номер которого указан в поле подтвержденного номера. Поле занимает 16 бит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checksum – поле, содержащее значение контрольной суммы, представляет собой 16 бит, дополняющие биты в сумме всех 16-битовых слов сегмента (само поле контрольной суммы перед вычислением обнуляется). </p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Контрольная сумма, кроме заголовка сегмента и поля данных, учитывает 96 бит псевдозаголовка, который для внутреннего употребления ставится перед TCP-заголовком. Этот псевдозаголовок содержит IP-адрес отправителя (4 октета), IP-адрес получателя (4 октета), нулевой октет, 8-битное поле "Протокол", аналогичное полю в IP-заголовке, и 16 бит длины TCP сегмента, измеренной в октетах. Такой подход обеспечивает защиту протокола TCP от перепутавших маршрут сегментов. Информация для псевдозаголовка передается через интерфейс "Протокол TCP/межсетевой уровень" в качестве результатов запросов от протокола TCP к протоколу IP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Urgent Pointer - указывает на конец данных, которые необходимо срочно принять, несмотря на переполнение буфера.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Другими словами поле используется для указания длины срочных данных, которые размещаются в начале поля данных сегмента. В поле указывается смещение октета, следующего за срочными данными, относительно первого октета в сегменте. Например, в сегменте передаются октеты с 2001-го по 3000-й, при этом первые 100 октетов являются срочными данными, тогда Urgent Pointer будет равно 100. Протокол TCP не определяет, как именно должны обрабатываться срочные данные, но предполагает, что прикладной процесс будет предпринимать усилия для их быстрой обработки. Поле Urgent Pointer задействовано, если установлен флаг URG. Поле занимает 16 бит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Options - это поле, используется для решения вспомогательных задач, например, для согласования максимального размера сегмента, имеет переменную длину и может вообще отсутствовать.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Опция состоит из октета "Тип опции", за которым могут следовать октет "Длина опции в октетах" и октеты с данными для опции.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Стандарт протокола TCP определяет три опции (типы 0, 1, 2)</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Опции типов 0 и 1 ("Конец списка опций" и "Нет операции" соответственно) состоят из одного октета, содержащего значение типа опции. При обнаружении в списке опции "Конец списка опций" разбор опций прекращается, даже если длина заголовка сегмента еще не исчерпана. Опция "Нет операции" может использоваться для выравнивания между опциями по границе 32 бит.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Опция типа 2 "Максимальный размер сегмента" состоит из 4 октетов: одного октета типа опции (значение равно 2), одного октета длины (значение равно 4) и двух октетов, содержащих максимальный размер сегмента, который способен получать TCP-модуль, отправивший сегмент с данной опцией. Опцию следует использовать только в SYN-сегментах на этапе установки соединения.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padding – это фиктивное поле может иметь переменную длину, используется для доведения размера заголовков до целого числа 32-битовых слов.</p>
</font>
<p align="center">
		<a name="5.4.2.2"><font class="big">5.4.2.2 Установление логического соединения </font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Основным отличием  протокола TCP от UDP является, то, что на протокол TCP возложена дополнительная задача – обеспечить надежную доставку сообщений, используя в качестве основы ненадежный дейтаграммный протокол IP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Для решения этой задачи протокол TCP использует метод продвижения данных с установлением логического соединения. Как было сказано ранее, логическое соединение дает возможность участника обмена следить за тем, чтобы данные не были потеряны, искажены или продублированы, а также чтобы они пришли к получателю в том порядке, в котором были отправлены.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол TCP  устанавливает логические соединения между прикладными процессами, причем в каждом соединении участвуют только два процесса. TCP – соединение является дуплексным, то есть каждый из участников этого соединения может одновременно получать и отправлять данные.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.29 показаны сети соединения маршрутизаторами, на которых установлен протокол IP. Установление на конечных узлах протокольные модули ТСР решают задачи обеспечения надежного обмена данными путем установления между  собой логических соединений.</p>
<p align="center"><img src="img/chapter5/5.29.jpg"/></p>
<p align="center">Рисунок 5.29 – TCP – соединение создает надежный логический канал между конечными узлами</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При установлении логического соединения модули TCP договариваются  между собой о параметрах процедуры  обмена данными. В протоколе TCP  каждая сторона соединения  посылает противоположной стороне  следующие параметры:
<ul>
<li>максимальный размер сегмента, который она готова принимать;</li>
<li>максимальный объем данных (возможно несколько сегментов),  которые она разрешает другой стороне передавать в свою сторону, даже если та еще не получила квитанцию на предыдущую порцию данных (размер окна);</li>
<li>начальный порядковый номер байта, с которого она начинает отсчет потока данных в рамках данного соединения.</li>
</ul>
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В результате  переговорного процесса модулей TCP с двух сторон соединения определяются параметры соединения. Одни из них остаются постоянными в течении всего сеанса связи, а другие адаптивно изменяются. В частности,  в зависимости от загрузки буфера принимающей стороны, а также надежности работы сети динамически изменяется размер окна отправителя.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Соединение устанавливается по инициативе клиентской части приложения. При необходимости выполнить обмен данными с серверной частью приложение – клиент обращается к нижележащему протоколу TCP, который в ответ на это обращение посылает сегмент – запрос на установление соединения протоколу TCP, работающему  на стороне сервера (рисунок 5.30, а). В числе прочего в запросе содержится флаг SYN, установленный в 1</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Получив запрос, модуль TCP на стороне сервера  пытается создать "инфраструктуру" для  обслуживания нового клиента. Он обращается к операционной системе с просьбой о выделении определенных системных ресурсов для организации буферов, таймеров, счетчиков. Эти ресурсы  закрепляются за соединением с момента создания и до момента разрыва. Если на стороне сервера все необходимые ресурсы были получены и все необходимые действия выполнены, то модуль ТСР посылает клиенту сегмент с флагами ACK и  SYN.</p>
<p align="center"><img src="img/chapter5/5.30.jpg"/></p>
<p align="center">Рисунок 5.30 – Процедура установления и разрыва логического соединения при нормальном течении процесса</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В ответ клиент посылает сегмент с флагом ACK и переходит в состоянии установленного логического соединения (состояние ESTABLISHED). Когда сервер получает флаг с ACK, он тоже переходит в состояние ESTABLISHED. На этом процедура установления соединения заканчивается, и стороны могут переходить к обмену данными.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Соединение может быть разорвано в любой момент по инициативе любой стороны. Для этого клиент и сервер должны обменяться  сегментами FIN  и ACK, в последовательности, показанной на рисунке 5.30 б (здесь инициатором является клиент). Соединение  считается закрытым по прошествии некоторого времени, в течение которого сторона – инициатор убеждается, что ее завершающий сигнал ACK дошел нормально и не вызвал никаких "аварийных " сообщений со стороны сервера.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Логическое TCP-соединение однозначно идентифицируется  парой сокетов, определенных для этого соединения  двумя  взаимодействующими процессами.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Сокет одновременно может участвовать в нескольких соединениях. Так на рисунке 5.31 показаны три компьютера с адресами  IP1,  IP2, IP3. На каждом компьютере выполняется по одному приложению – APPL1,  APPL2 и  APPL3, сокеты которых соответственно (IP1, n1), (IP2, n2), (IP3, n3), а номер TCP – портов  приложений n1, n2, n3.</p>
<p align="center"><img src="img/chapter5/5.31.jpg"/></p>
<p align="center">Рисунок 5.31 – Один сокет может участвовать в нескольких соединениях</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке показаны два логических соединения, которое установило приложение 2 с приложением 1 и приложением 3. Логическое соединения идентифицируются как {(IP2,n2), (IP1,n1)}и{(IP2,n2), (IP3,n3)} соответственно. Мы видим, что в обоих соединениях участвует один и тот же сокет -  (IP2, n2)</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Далее представлен пример, как протокол TCP выполняет демультиплексирование.  Пусть некий поставщик услуг оказывает услугу по Web-хостингу, то есть на его  компьютере клиенты могут разворачивать свои Web-серверы.  Web – сервер основан на протоколе прикладного уровня http, который передает свои сообщения в TCP- сегментах. Модуль TCP ожидает запросы от Web -клиентов (браузеров), "прослушивая" хорошо известный порт 80.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.32 показан вариант хостинга с двумя Web-серверами, сервером www1.model.ru, имеющим IP-адрес IP1, и сервером www2.tour.ru, с адресом IP2.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;К каждому из них может обращаться множество клиентов, причем клиенты могут одновременно работать как с сервером www1, так и с сервером www2. Для каждой пары клиент – сервер протоколом TCP создается отдельное логическое соединение.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке показаны два браузера, имеющие соответственно сокеты (IPk, nk) и (IPm, nm). Пользователь браузера k обращается одновременно к серверам www1 и www2. Наличие отдельных соединений для работы с каждым из этих серверов обеспечивает не только надежную доставку, но и разделение информационных потоков – у пользователей никогда не возникает вопроса, каким сервером ему была послана та или иная страница. Одновременно с пользователем браузера k, с сервером www2 работает пользователь браузера m. И в этом случае отдельные логические соединения, в рамках которых идет работа обоих пользователей, позволяют изолировать их информационные потоки. На рисунке показаны буферы, количество которых определяется не числом Web-сервером и не числом клиентов, а числом логических соединений. Сообщения в эти буферы направляются в зависимости от значений сокетов как отправителя, так и получателя. Отсюда можно сделать вполне конкретный вывод.</p>
<p align="center"><img src="img/chapter5/5.32.jpg"/></p>
<p align="center">Рисунок 5.32 – Демультиплексирование протокола ТСР на основе соединений</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Демультиплексирование протокола ТСР на основе соединений</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол ТСР осуществляет демультиплексирование информации, поступающей на прикладной уровень, на основе соединений процессов или, что одно и то же, на основе идентифицирующих эти процессы пар сокетов.</p>
</font>
<p align="center">
		<a name="5.4.2.3"><font class="big">5.4.2.3 Управление потоком</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Какой размер окна должен назначить источник приемнику, и наоборот? Точнее, каким на  каждой из сторон должно быть выбрано время ожидания (тайм-аут) очередной квитанции? От ответа на этот вопрос зависит производительность протокола TCP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При выборе величины тайм-аута должны учитываться скорость и надежность линий связи, их протяженность и многие другие факторы. Тайм-аут не должен быть слишком коротким, чтобы по возможности исключить избыточные повторные передачи, снижающие полезную пропускную способность системы, но он не должен быть и слишком длинным чтобы избежать длительных простоев, связанных с ожиданием несуществующей или "заблудившейся" квитанции.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В протоколе TCP тайм-аут определяется с помощью достаточно сложного адаптивного алгоритма, идея которого состоит в следующем. При каждой передаче засекается время от момента отправки сегмента до прихода квитанции о его приеме (время оборота). Получаемые значения времени оборота усредняются с весовыми коэффициентами, возрастающими от предыдущего замера к последующему. Это делается с тем, чтобы усилить влияние последних замеров. В качестве тайм-аута выбирается среднее время оборота, умноженное на некоторый коэффициент. Практика показывает, что значение этого коэффициента должно превышать 2. В сетях с большим разбросом времени оборота при выборе тайм-аута учитывается и дисперсия этой величины.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Размер окна приема связан с наличием в данный момент места в буфере данных у принимающей стороны. Поэтому в общем случае окна приема на разных концах соединения имеют разный размер. Например, можно ожидать, что сервер, вероятно обладающий большим буфером, пошлет клиентской станции окно приема большее, чем клиент серверу. В зависимости от состояния сети то одна, то другая стороны могут объявлять новые значения он приема, динамически уменьшая и увеличивая их.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Варьируя величину окна, можно влиять на загрузку сети. Чем больше окно, тем большая порция неподтвержденных данных может быть послана в сеть. Но если пришло большее количество данных, чем может быть принято модулем TCP, данные отбрасываются. Это ведет излишним пересылкам информации и ненужному росту нагрузки на сеть и модуль TCP.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В то же время окно малого размера может ограничить передачу данных скоростью, которая определяется временем путешествия по сети каждого посылаемого сегмента. Чтобы избежать применения малых окон, в некоторых реализациях TCP предлагается получателю данных откладывать реальное изменение размеров окна до тех пор, пока свободное место не составит 20-40% от максимально возможного объема памяти для этого соединения. Но и отправителю не стоит спешить с посылкой данных, пока окно принимающей стороны не станет достаточно большим. Учитывая эти соображения, разработчики протокола TCP предложили схему, согласно которой при установлении соединения заявляется большое окно, но впоследствии его размер существенно уменьшается. Существуют и другие прямо противоположные алгоритмы настройки окна, когда вначале выбирается минимальное окно, а затем, если сеть справляется с предложенной нагрузкой, его размер резко увеличивается.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Управлять размером окна приема может не только та сторона, которая посылает это окно, чтобы регулировать поток данных в свою сторону, но и вторая сторона - потенциальный отправитель данных. Если вторая сторона фиксирует ненадежную работу линии связи (регулярно запаздывают квитанции, часто требуется повторная передача), то она может по собственной инициативе уменьшить окно. В таких случаях действует правило: в качестве действующего размера окна выбирается минимальное из двух значений: значения, диктуемого приемной стороной, и значения, определяемого "на месте" отправителем.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Признаком перегрузки TCP-соединения является возникновение очередей на промежуточных узлах (маршрутизаторах) и на конечных узлах (компьютерах). При переполнении приемного буфера конечного узла "перегруженный" модуль TCP, отправляя квитанцию, помещает в нее новый уменьшенный размер окна. Если он совсем отказывается от приема, то в квитанции указывается окно нулевого размера. Однако даже после этого приложение может послать сообщение на отказавшийся от приема порт. Для этого сообщение должно сопровождаться указателем срочности. В такой ситуации порт обязан принять сегмент, даже если для этого придется вытеснить из буфера уже находящиеся там данные. После приема квитанции с нулевым значением окна протокол-отправитель время от времени делает контрольные попытки продолжить обмен данными. Если протокол-приемник уже готов принимать информацию, то в ответ на контрольный запрос он посылает квитанцию с указанием ненулевого размера окна.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Как видно далеко не полного описания двух протоколов транспортного уровня стека TCP/IP, на один из них - TCP - возложена сложная и очень важная задача: обеспечение надежной передачи данных через ненадежную сеть.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В то же время функциональная простота протокола UDP обуславливает простоту алгоритма его работы, компактность и высокое быстродействие. Поэтому те приложения, в которых реализован собственный, достаточно надежный механизм обмена сообщениями основанный на установлении соединения, предпочитают для непосредственной передачи данных по сети использовать менее надежные, но более быстрые средства транспортировки, в качестве которых по отношению к протоколу TCP и выступает протокол UDP. Протокол UDP может применяться и тогда, когда хорошее качество линий связи обеспечивают достаточный уровень надежности и без применения дополнительных приемов наподобие установления логического соединения и квитирования передаваемых пакетов. Заметим также, что поскольку протокол TCP основан на логических соединениях, он, в отличие от протокола UDP, не годится для широковещательной и групповой рассылки.</p>
</font>
<p align="center">
		<a name="5.4.3"><font class="big">5.4.3 Использование методов повторной передачи и скользящего окна на транспортном уровне</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Один из наиболее естественных приемов, используемых для организации надежной передачи – это квитирование. Отправитель отсылает данные и ждет, пока к нему не придет квитанция, подтверждающая, что его данные благополучно дошли до адресата. В протоколе ТСР  используется частный  случай квитирования  алгоритм скользящего окна. Прежде  чем перейти к подробному рассмотрению особенностей реализации этого алгоритма в протоколе ТСР, необходимо рассмотреть его с общих позиций.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Итак, существует два метода организации процесса обмена квитанциями метод простоя источника и метод скользящего окна.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Метод простоя источника  требует, чтобы источник, пославший кадр (в данном случае не имеет значения, какое название используется для единицы передаваемых данных), дожидался от приемника квитанции, извещающей о том, что исходный кадр получен и данные в нем корректны, и  только после этого посылал следующий кадр (или повторял искаженный). На рисунке 5.33 показано, что второй кадр отсылается только после того, как пришла квитанция, подтверждающая доставку первого кадра. Однако затем произошла длительная пауза в отправке следующего третьего кадра. В течение этой паузы источник был вынужден повторить передачу кадра 2, так как квитанция на первую его копию была потеряна. Понятно, что при таком алгоритме работы источника принимающая сторона должна уметь распознавать дублирующиеся кадры и избавляться от них.</p>
<p align="center"><img src="img/chapter5/5.33.jpg"/></p>
<p align="center">Рисунок 5.33 – Метод простоя источника</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Достаточно очевидно, что при использовании данного метода производительность обмена данными ниже потенциально возможной – передатчик мог бы посылать следующий кадр сразу же после отправки предыдущего, но он обязан ждать прихода квитанции.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Второй метод называется методом скользящего окна. В этом методе для повышения скорости передачи данных источнику разрешается  передать некоторое  количество кадров от 1 до 5 включительно. Источник начинает передавать кадры и через какое–то время получать ответ от квитанции. Для простоты предположим, что квитанции поступают в той же последовательности (но не обязательно в том же темпе), что и кадры, которым они соответствуют. В момент получения отправителем квитанции окно сдвигается на одну позицию вверх, определяя новый диапазон разращенных к отправке кадров (от 2 до 6).</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Процессы отправки пакетов и получения квитанции идут достаточно независимо друг от друга. В нашем примере отправитель продолжает передавать кадры, но некоторое время не получает от них квитанции. После передачи кадра 6 окно исчерпывается, и источник приостанавливает передачу.</p>
<p align="center"><img src="img/chapter5/5.34.jpg"/></p>
<p align="center">Рисунок 5.34 – Метод скользящего окна</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;После получения квитанции 2 (на кадр 2) окно сдвигается вверх на единицу, определяя диапазон разрешенных к передаче кадров от 3 до 7. Аналогичное "скольжение" окна вверх происходит после получения каждой квитанции:  окно сдвигается вверх на 1, но его размер при этом не меняется и остается равным 5. После прихода квитанции 8, окно оказывается в диапазоне от 9 до 13 и остается таковым достаточно долго, так как по каким–то причинам источник перестает получать подтверждение о доставке кадров. Отправив последний разрешенный кадр 13, передатчик снова  прекращает передачу с тем, чтобы возобновить ее после прихода квитанции 9.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При отправке кадра в источнике устанавливается тайм – аут. Если за установленное время квитанция, на отправленный кадр не придет, то кадр (или квитанция на него), считается утерянным, и кадр передается снова. Если же поток квитанции поступает регулярно в пределах допуска в 5 кадров, то скорость обмена достигает максимально возможной величины для данного канала и принятого протокола.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В общем случае метод скользящего окна сложен в реализации, чем метод простоя источника, так как передатчик должен хранить в буфере копии всех кадров, на которые пока не получены квитанции. Кроме того, при использовании данного метода требуется отслеживать несколько параметров алгоритма, таких как размер окна, номер кадра на который получена квитанция, номер кадра, который еще можно передать до получения новой квитанции.</p>
</font>
<p align="center">
		<a name="5.4.3.1"><font class="big">5.4.3.1 Реализация метода скользящего окна в протоколе ТСР</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм скользящего окна в протоколе ТСР имеет некоторые существенные особенности. В частности, в рассматриваемом обобщенном алгоритме скользящего окна единицей передаваемых данных является кадр, и  размер окна также определяется в кадрах, в то время как в протоколе ТСР  дело обстоит совсем по-другому.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Хотя единицей передаваемых данных протокола ТСР является сегмент (аналог кадра в данном контексте), окно определено на множестве нумерованных байтов неструктурированного потока данных, передаваемого приложением протоколу ТСР.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В ходе переговорного процесса модули ТСР обоих участвующих в обмене сторон договариваются между собой о параметрах процедуры обмена данными.  Одни из них остаются постоянными в течение всего сеанса связи, другие в зависимости, например. От интенсивности трафика и / или размеров буферов адаптивно изменяются.  Одним из таких параметров является начальный номер байта, с которого будет вестись отсчет в течение всего функционирования данного соединения. У каждой стороны свой начальный номер. Нумерация байтов в пределах сегмента осуществляется, начиная от заголовка (рисунок 5.35)</p>
<p align="center"><img src="img/chapter5/5.35.jpg"/></p>
<p align="center">Рисунок 5.35 – Нумерация байтов в ТСР-сегменте</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда отправитель посылает ТСР-сегмент, он помещает в поле последовательного номера, номер первого байта данного сегмента, который служит идентификатором сегмента. На рисунке 5.36 показаны четыре сегмента размером 1460 байт и один -  870 байт. Идентификаторами этих сегментов являются номера 32600, 34060, 35520 ит.д. На основании этих номеров получатель ТСР-сегмента не только отличает данный сегмент от других, но и поможет сделать вывод, например, что полученный сегмент является дубликатом или, что между двумя полученными сегментами пропущены данные и т.д.</p>
<p align="center"><img src="img/chapter5/5.36.jpg"/></p>
<p align="center">Рисунок 5.36 – Порядковый номер и номер квитанции</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В качестве квитанции получатель сегмента отсылает ответное сообщение (сегмент), в поле подтвержденного номера которого он помещает число, на единицу превышающего максимальный номер байта в полученном сегменте. Так, для первого отправленного сегмента, изображенного на рисунке 5.36, квитанцией о получении (подтвержденным номером) будет число 34060, для второго – 35520 и т.д. Подтвержденный номер  часто интерпретирует не только оповещение о благополучной доставке, но и как номер следующего ожидаемого байта данных.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Квитанция в протоколе ТСР посылает только в случае правильного приема данных. Таким, образом, отсутствие квитанции означает либо потерю сегмента, либо потерю квитанции, либо прием искаженного сегмента.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;В соответствии с определенным форматом один и тот же ТСР-сегмент может нести в себе как пользовательские данные (в поле данных), так и квитанцию, (в заголовке), которой подтверждается получение данных от другой стороны.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Поскольку ТСР является дуплексным, каждая сторона одновременно выступает и как отправитель, и как получатель. У каждой стороны есть пара буферов: один – для хранения принятых сегментов, другой – для сегментов, которые  только еще предстоит отправить. Кроме того, имеется буфер для хранения копий сегментов, которые были отправлены, но квитанции о получении которых еще не поступили (рисунок 5.37)</p>
<p align="center"><img src="img/chapter5/5.37.jpg"/></p>
<p align="center">Рисунок 5.37 – Система буферов ТСР-соединения</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;И при установлении соединения, и в ходе передачи обе стороны, выступая в роли получателя, посылают друг к  другу так называемые окна приема. Каждая из сторон, получив окно приема, "узнает", сколько байтов ей разрешается отправить  с момента получения  последней квитанции. Другими словами, посылая окна приема, обе стороны пытаются регулировать поток байтов в свою сторону, сообщая своему "визави", какое количество байтов (начиная с номера байта, о котором уже была выслана квитанция) они готовы в настоящий момент принять.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;На рисунке 5.38 показан поток байтов, поступающий от приложений в выходной буфер модуля ТСР "нарезает" последовательность сегментов и поочередно отправляет их приложению – получателю. Для определенности на рисунке принято направление перемещения данных справа налево. В этом потоке можно указать несколько логических границ:
<ul>
<li>Первая граница определяет сегменты, которые уже были отправлены и на которые уже пришли квитанции. Последняя квитанция пришла на байт с номером N.</li>
<li>По другую сторону этой границы располагается окно размером W байт. Часть байтов, входящих в окно, составляют сегменты, которые также уже отправлены, но квитанции, на которые пока не получены.</li>
<li>Оставшаяся часть окна – это сегменты, которые пока не отправлены, но могут быть отправлены, так как входят в пределы окна.</li>
<li>И наконец, последняя граница указывает на начало последовательности сегментов, ни один из которых не может быть отправлен до тех пор, пока не придет очередная квитанция, и окно не будет сдвинуто в право.</li>
</ul>
</p>
<p align="center"><img src="img/chapter5/5.38.jpg"/></p>
<p align="center">Рисунок 5.38 – Особенности реализации алгоритма скользящего окна в протоколе ТСР</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Если размер окна равен W, а последняя по времени квитанция содержала значение N, то отправитель может посылать новые сегменты до тех пор, пока в очередной сегмент не попадает байт с номером N + W. Этот сегмент выходит за рамки окна  и передачу в таком случае  необходимо приостановить до прихода следующей квитанции.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Получатель может послать квитанцию, подтверждения получения  сразу нескольких  сегментов, если они образуют непрерывный поток байтов.  Например, (рисунок 5.39, а), если в буфер, плотно без пропусков заполненный потоком байтов до 2354 включительно,  поочередно поступили сегменты (2355-3816), (3817-5275) и (5276-8400), где цифры в скобках обозначают номера первых и последних байтов каждого сегмента, то получателю достаточно отправить только одну квитанцию на все тир сегмента, указав в ней в качестве номера квитанции значение 8401. Таким образом, процесс квитирования в ТСР является накопительным.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Вполне возможны ситуации, когда сегменты приходят к получателю не в том порядке, в котором были посланы, то есть в приемном буфере может образоваться "прогалина" (рисунок 5.40, б). Пусть, к примеру, после указанных ранее трех сегментов вместо следующего по порядку сегмента (8401 - 10566) пришел сегмент (10567-12430). Очевидно, что послать в качестве номера квитанции значение 12431 нельзя, потому что это бы означало, что получены все байты вплоть до 12430. Поскольку в потоке байтов образовался разрыв, получатель может только еще раз повторить квитанцию 8401, говоря тем самым, что он еще ожидает поступления потока байтов, начиная с 8401, то есть подтверждает получение не отдельных блоков данных, а непрерывной последовательности байтов.</p>
<p align="center"><img src="img/chapter5/5.39.jpg"/></p>
<p align="center">Рисунок 5.39 – Накопительный принцип квитирования:<br>
а – полное заполнение буфера (в момент t4 передается квитанция на байт 8401),<br>
б – неполное заполнение буфера (в момент t5 снова передается квитанция на байт 8401)
</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Когда протокол TCP передает в сеть сегмент, он «на всякий случай» помещает его копию в буфер, называемый также очередью повторной передачи, и запускает таймер. Когда приходит квитанция на этот сегмент, соответствующая копия удаляется из очереди. Если же квитанция не приходит до истечения срока, то сегмент, вернее его копия, посылается повторно. Может случиться так, что копия сегмента придет тогда, когда исходный сегмент уже окажется на месте, тогда дубликат попросту отбрасывается</p>
</font>
<p align="center">
		<a name="5.4.4"><font class="big">5.4.4 Протокол UDP и UDP – дейтаграммы</font></a>
</p>
<font class="norm">
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Протокол UDP, подробно IP, является дейтаграммным протоколом, реализующим  так называемый ненадежный  сервис возможности, который не гарантирует доставку сообщений адресату.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;При работе на хосте – отправителе данные от приложений поступают протоколу UDP через порт в виде сообщений (рисунок 5.40). Протокол UDP добавляет к каждому отдельному сообщению свой 8 – байтный заголовок, формируя из этих   сообщений собственные протокольные единицы, называемые UDP- дейтаграммами, и передает их нижележащему протоколу  IP. В этом и заключаются его функции по <em>мультиплексированию</em> данных.</p>
<p align="center"><img src="img/chapter5/5.40.jpg"/></p>
<p align="center">Рисунок 5.40 – Накопительный принцип квитирования:</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Каждая дейтаграмма  переносит отдельное пользовательское сообщение. Сообщения могут иметь различную длину, не превышающую, однако длину поля данных протокола IP, которое, в свою очередь, ограниченно размером кадра технологии нижнего уровня. Поэтому если буфер UDP переполняется, то сообщение приложения отбрасывается.</p>
<ul>Заголовок UDP состоит из четырех 2-х байтных полей:
<li>номер UDP-порта отправителя;</li>
<li>номер UDP-порта получателя;</li>
<li>контрольная сумма;</li>
<li>длина дейтаграммы;</li>
</ul>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Судя по простоте  заголовка, протокол UDP не сложен.  Действительно, его функции сводятся к простой передаче  данных между  прикладными и сетевыми уровнями, а также примитивному контролю искажений в передаваемых данных. При контроле искажений  протокол UDP  только диагностирует,  но не исправляет ошибку. Если  контрольная сумма  показывает, что после данных UDP – дейтаграммы  произошла ошибка, протокол  UDP просто отбрасывает поврежденную дейтаграмму.</p>
<p style="text-align:justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Работая на хосте-получателе, протокол UDP принимает от протокола IP извлеченные из пакета UDP – дейтаграммы. Полученные  из IP - заголовка IP  - адрес назначения и из UDP – заголовка номер порта используются для формирования UDP – сокета, однозначно идентифицирующего приложения, которому направлены данные. Протокол UDP освобождает дейтаграмму от  UDP – заголовка. Полученное в результате сообщение он передает  приложению, на соответствующий UDP – сокет. Таким образом, протокол UDP выполняет демультиплексирование на основе сокетов.</p>
</font>
<br>
<br>
<table align="center">
	<tr>
		<td width="220" align="left"><a href="4.htm#4"><font class="norm">&lt;&lt; Предыдущая глава</font></a></td>
        <td width="220" align="right"><a href="6.htm#6"><font class="norm">Следующая глава >></font></a></td>
    </tr>
</table>
<br>
<br>
</body>
</html>
